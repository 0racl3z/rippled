package newcoin;

enum MessageType {
// core
	HELLO=			0; 
	ERROR_MSG=		1;
	PING=			2;

// network presence detection
	GET_CONTACTS=		10;
	CONTACT=		11;


// operations for 'small' nodes
	SEARCH_TRANSACTION=	20;
	GET_ACCOUNT=		21;
	ACCOUNT=		22;

// transaction and ledger processing
	TRANSACTION=		30;
	GET_LEDGER=		31;
	LEDGER=			32;
	PROPOSE_LEDGER=		33;
	CLOSE_LEDGER=		34;

// data replication and synchronization
	GET_VALIDATIONS=	40;
	VALIDATION=		41;
	GET_OBJECT=		42;
	OBJECT=			43;
}


message TMBaseMessage {
	required MessageType type		= 1;
	optional uint32 seq			= 2;
	optional uint32 querySeq		= 3; // if this is a reply
	required bytes innerMessage		= 4;
}


// Sent on connect
message TMHello {
	required uint32 version			= 1;
	optional uint32 ledgerIndex		= 2;
	optional uint64 netTime			= 3;
	optional bytes nodeID			= 4; // node may opt to remain anonymous
}


/*
A transaction can have only one input and one output.
If you want to send an amount that is greater than any single address of yours
you must first combine coins from one address to another.
*/

message TMTransaction {
	required bytes from			= 1;
	required bytes dest			= 2;
	required uint64 amount			= 3;
	required uint32 sourceLedgerIndex	= 4;
	required uint32 seqNum			= 5;
	required uint32 ident			= 6;
	required bytes pubKey			= 7;
	required bytes sig			= 8;
	optional uint32 ledgerIndex		= 10; // the node may not know
}


// Used to propose/validate during ledger close
message TMValidation {
	required uint32 ledgerIndex		= 1;
	required bytes ledgerHash		= 2;
	optional uint64 timestamp		= 3; // only in proposed ledgers
	optional uint32 confidence		= 4; // only in proposed ledgers
	required bytes hanko			= 5;
	required bytes sig			= 6;
}



message TMGetValidations {
	required uint32 ledgerIndex		= 1;
	repeated bytes hanko			= 2;
	optional uint32 count			= 3; // get random validations
}



message TMContact {
	required bytes pubKey			= 1;
	required uint32 softwareVersion		= 2;
	required uint32 protoVersion		= 3;
	required uint64 nodeFlags		= 4;
	required uint64 timestamp		= 5;
	repeated bytes nodeInfo			= 6;
	required bytes signature		= 7;
}

// request node information
message TMGetContacts {
	repeated bytes nodeIDs			=1; // specific nodes we want
	optional uint32 nodeCount		=2; // get some random nodes
}



message TMIndexedObject
{
	enum ObjectType {
		TRANSACTION		= 1;
		TRANSACTION_NODE	= 2; // a node in a transaction tree
		TRANSACTION_LEAF	= 3; // a leaf in a transaction tree
		ACCOUNT			= 4; // a single account state (with balance/sequence)
		ACCOUNT_NODE		= 5; // a node in an account state tree
		ACCOUNT_LEAF		= 6; // a leaf in an account state tree
		LEDGER			= 7;
	}

	required bytes hash		= 1;
	required ObjectType type	= 2;
}



message TMGetObjectByHash
{
	required TMIndexedObject object	= 1;
}



message TMObjectByHash
{
	required TMIndexedObject object	= 1;
	required bytes data		= 2;
}




message TMPing {
	enum pingType {
		PING = 0; // we want a reply
		PONG = 1; // this is a reply
	}
	required pingType type		= 1;
	optional uint32 pingVal		= 2; // detect stale replies, ensure other side is reading
	optional uint64 pingTime	= 3; // know when we think we sent the ping
	optional uint64 netTime		= 4;
}


message TMErrorMsg {
	optional int32 errorCode		= 1;
	optional string message			= 2;
}

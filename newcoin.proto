package newcoin;

enum Type {
// abnormal
	ERROR_MSG=		1;

// session management
	HELLO=			10; 
	PING=			11;

// transaction processing
	TRANSACTION=		20;

// ledger closing
	PROPOSE_LEDGER=		30;
	CLOSE_LEDGER=		31;

// data replication and synchronization
	GET_VALIDATIONS=	40;
	VALIDATION=		41;
	GET_CONTACTS=		42;
	CONTACT=		43;
	GET_OBJECT=		44;
	OBJECT=			45;

}


// Sent on connect
message Hello {
	required uint32 version			= 1;
	optional uint32 ledgerIndex		= 2;
	optional uint64 netTime			= 3;
	optional bytes nodeID			= 4; // node may opt to remain anonymous
}


/*
A transaction can have only one input and one output.
If you want to send an amount that is greater than any single address of yours
you must first combine coins from one address to another.
*/

message Transaction {
	required bytes from			= 1;
	required bytes dest			= 2;
	required uint64 amount			= 3;
	required uint32 sourceLedgerIndex	= 4;
	required uint32 seqNum			= 5;
	required uint32 ident			= 6;
	required bytes pubKey			= 7;
	required bytes sig			= 8;
	optional uint32 ledgerIndex		= 10; // the node may not know
}


// Used to propose/validate during ledger close
message Validation {
	required uint32 ledgerIndex		= 1;
	required bytes ledgerHash		= 2;
	optional uint64 timestamp		= 3; // only in proposed ledgers
	optional uint32 confidence		= 4; // only in proposed ledgers
	required bytes hanko			= 5;
	required bytes sig			= 6;
}



message GetValidations {
	required uint32 ledgerIndex		= 1;
	repeated bytes hanko			= 2;
	optional uint32 count			= 3; // get random validations
}



message Contact {
	required bytes pubKey			= 1;
	required uint32 softwareVersion		= 2;
	required uint32 protoVersion		= 3;
	required uint64 nodeFlags		= 4;
	required uint64 timestamp		= 5;
	repeated bytes nodeInfo			= 6;
	required bytes signature		= 7;
}

// request node information
message GetContacts {
	repeated bytes nodeIDs			=1; // specific nodes we want
	optional uint32 nodeCount		=2; // get some random nodes
}



message IndexedObject
{
	enum ObjectType {
		TRANSACTION		= 1;
		TRANSACTION_NODE	= 2; // a node in a transaction tree
		TRANSACTION_LEAF	= 3; // a leaf in a transaction tree
		ACCOUNT			= 4; // a single account state (with balance/sequence)
		ACCOUNT_NODE		= 5; // a node in an account state tree
		ACCOUNT_LEAF		= 6; // a leaf in an account state tree
		LEDGER			= 7;
	}

	required bytes hash		= 1;
	required ObjectType type	= 2;
}



message GetObjectByHash
{
	required IndexedObject object	= 1;
}



message ObjectByHash
{
	required IndexedObject object	= 1;
	required bytes data		= 2;
}




message Ping {
	enum pingType {
		PING = 0; // we want a reply
		PONG = 1; // this is a reply
	}
	required pingType type		= 1;
	optional uint32 pingVal		= 2; // detect stale replies, ensure other side is reading
	optional uint64 pingTime	= 3; // know when we think we sent the ping
	optional uint64 netTime		= 4;
}


message ErrorMsg {
	optional int32 errorCode		= 1;
	optional string message			= 2;
}

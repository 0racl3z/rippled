package newcoin;

enum MessageType {
// core
	HELLO=			0; 
	ERROR_MSG=		1;
	PING=			2;

// network presence detection
	GET_CONTACTS=	10;
	CONTACT=		11;


// operations for 'small' nodes
	SEARCH_TRANSACTION=	20;
	GET_ACCOUNT=		21;
	ACCOUNT=			22;

// transaction and ledger processing
	TRANSACTION=		30;
	GET_LEDGER=			31;
	LEDGER=				32;
	PROPOSE_LEDGER=		33;
	CLOSE_LEDGER=		34;

// data replication and synchronization
	GET_VALIDATIONS=	40;
	VALIDATION=			41;
	GET_OBJECT=			42;
	OBJECT=				43;
}


// Sent on connect
message TMHello {
	required uint32 version			= 1;
	optional uint32 ledgerIndex		= 2;
	optional uint64 netTime			= 3;
	optional bytes nodeID			= 4; // node may opt to remain anonymous
}


/*
A transaction can have only one input and one output.
If you want to send an amount that is greater than any single address of yours
you must first combine coins from one address to another.
*/

enum TransactionStatus {
	NEW				= 1;	// origin node did/could not validate
	CURRENT			= 2;	// scheduled to go in this ledger
	COMMITED		= 3;	// in a closed ledger
	REJECT_CONFLICT	= 4;
	REJECT_INVALID	= 5;
	REJECT_FUNDS	= 6;
	HELD_SEQ		= 7;
	HELD_LEDGER		= 8;	// held for future ledger
}

message TMTransaction {
	required bytes from					= 1;
	required bytes dest					= 2;
	required uint64 amount				= 3;
	required uint32 sourceLedgerIndex	= 4;
	required uint32 seqNum				= 5;
	required uint32 ident				= 6;
	required bytes pubKey				= 7;
	required bytes sig					= 8;
	required TransactionStatus status	= 9;
	optional uint64 receiveTimestamp	= 10;
	optional uint32 ledgerIndexPossible	= 11; // the node may not know
	optional uint32 ledgerIndexFinal	= 12;
	optional bytes conflictingTransaction	= 13;
}


// Used to propose/validate during ledger close
message TMValidation {
	required uint32 ledgerIndex		= 1;
	required bytes ledgerHash		= 2;
	optional uint64 timestamp		= 3; // only in proposed ledgers
	optional uint32 confidence		= 4; // only in proposed ledgers
	required bytes hanko			= 5;
	required bytes sig				= 6;
}



message TMGetValidations {
	required uint32 ledgerIndex		= 1;
	repeated bytes hanko			= 2;
	optional uint32 count			= 3; // get random validations
}



message TMContact {
	required bytes pubKey				= 1;
	required uint32 softwareVersion		= 2;
	required uint32 protoVersion		= 3;
	required uint64 nodeFlags			= 4;
	required uint64 timestamp			= 5;
	repeated bytes nodeInfo				= 6;
	required bytes signature			= 7;
}

// request node information
message TMGetContacts {
	repeated bytes nodeIDs			=1; // specific nodes we want
	optional uint32 nodeCount		=2; // get some random nodes
}


message TMSearchTransaction {
	required uint32 maxTrans	=1;
	optional bytes toAccount	=2;
	optional bytes fromAccount	=3;
	optional uint32	minLedger	=4;
	optional bytes fromAcctSeq	=5;
	repeated bytes transID		=6;
}

message TMGetAccount {
	repeated bytes acctID		=1;
	optional uint32 seq			=2;
}

message Account {
	required bytes accountID	=1;
	required uint64 balance		=2;
	required uint32 accountSeq	=3;
	required uint32 ledgerSeq	=4;
}

message TMAccount{
	repeated Account accounts	=1;
	optional uint32 seq			=2;
}

message TMIndexedObject
{
	enum ObjectType {
		TRANSACTION			= 1;
		TRANSACTION_NODE	= 2; // a node in a transaction tree
		TRANSACTION_LEAF	= 3; // a leaf in a transaction tree
		ACCOUNT				= 4; // a single account state (with balance/sequence)
		ACCOUNT_NODE		= 5; // a node in an account state tree
		ACCOUNT_LEAF		= 6; // a leaf in an account state tree
		LEDGER				= 7;
	}

	required bytes hash			= 1;
	required ObjectType type	= 2;
}



message TMGetObjectByHash
{
	required TMIndexedObject object	= 1;
	optional uint32 seq				= 2;	// used to match replies to queries
}

message TMObjectByHash
{
	optional TMIndexedObject object	= 1;	// present unless no object found
	optional bytes data				= 2;	// present unless no object found
	optional uint32 seq				= 3;	// matches seq from query
}

message LedgerNodes {
	required bytes nodeid			= 1;
	required bytes nodedata			= 2;
}

message TMGetLedger {
	optional bytes hash				= 1;
	optional uint32 ledgerSeq		= 2;
	repeated LedgerNodes nodes		= 3;
	optional uint32 seq				= 4;	// used to match replies to queries
}

message TMLedger {
	required bytes hash				= 1;
	repeated LedgerNodes nodes		= 2;
	optional uint32 seq				= 3;	// matches seq from query
}


message TMPing {
	enum pingType {
		PING = 0; // we want a reply
		PONG = 1; // this is a reply
	}
	required pingType type		= 1;
	optional uint32 seq			= 2; // detect stale replies, ensure other side is reading
	optional uint64 pingTime	= 3; // know when we think we sent the ping
	optional uint64 netTime		= 4;
}


message TMErrorMsg {
	optional int32 errorCode	= 1;
	optional string message		= 2;
}

package newcoin;

enum Type { 
	HELLO=				1; 
	TRANSACTION=		2; 
	FULL_LEDGER=		3;
	VALIDATION=			4; 
	PROPOSE_LEDGER=		5;
	GET_FULL_LEDGER=	6;
	GET_VALIDATIONS=	7;
	GET_CONTACTS=		8;
	CONTACT=			9;
	ERROR_MSG=			10;
}

// Sent on connect
message Hello {
	required int32 version			= 1;
	required bytes nodeID			= 2;
	required int32 port				= 3;
}


/*
A transaction can have only one input and one output.
If you want to send an amount that is greater than any single address of yours
you must first combine coins from one address to another.
*/
// TODO: do we need a transID? I don't think we do
// ledgerIndex should increase the ledger coherence
message Transaction {
	required bytes from				= 1;
	required bytes dest				= 2;
	required uint64 amount			= 3;
	required uint32 ledgerIndex		= 4;
	required int32 seqNum			= 5;
	required bytes pubKey			= 6;
	required bytes sig				= 7;
}

// Sequence number is incremented if you must change the ledger that you are validating
// You will only need to change validation in cases of incompatible ledgers 
// hanko is 160 bits. We store the full public key in the UNL
message Validation {
	required uint32 ledgerIndex		= 1;
	required bytes hash				= 2;
	required bytes hanko			= 3;
	required int32 seqNum			= 4;
	required bytes sig				= 5;
}

// seqnum should == last transaction seqnum+1
message Account {
	required bytes address			= 1;
	required uint64 amount			= 2;
	required uint32 seqNum			= 3;
}

// The ledger hash includes:
// index,accounts,feeHeld,transactions?
message FullLedger {
	required uint32 index				= 1;
	required bytes hash					= 2;
	required bytes parentHash			= 3;
	required uint64 feeHeld				= 4;
	repeated Account accounts			= 5;
	repeated Transaction transactions	= 6;
}


message GetFullLedger {
	required bytes hash				= 1;
}

message GetValidations {
	required uint32 ledgerIndex		= 1;
}

message Contact {
	required string nodeID			= 1;
	required string nodeIP			= 2;
	required int32 port				= 3;
}

// I thought about adding a hash of the transactions here so you know if the difference is 
// due to a different set of transactions or to a different parent
// but I think the times this will happen are very rare so it's probably not worth it
// but it might be worth also sending a hash of the accounts since if these match you don't care that the transactions don't
message ProposeLedger {
	required uint32 ledgerIndex		= 1;
	required bytes hash				= 2;
	optional uint64 numTransactions	= 3;
}

message ErrorMsg {
	optional int32 errorCode		= 1;
	optional string message			= 2;
}
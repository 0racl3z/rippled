package newcoin;

enum Type { 
	HELLO=				1; 
	TRANSACTION=		2; 
	FULL_LEDGER=		3;
	VALIDATION=			4; 
	GET_FULL_LEDGER=	5;
	GET_VALIDATIONS=	6;
	GET_CONTACTS=		7;
	CONTACT=			8;
	PROPOSE_LEDGER=		9;
	ERROR_MSG=			10;
}

// Sent on connect
message Hello {
	required int32 version			= 1;
	required bytes nodeID			= 2;
	required int32 port				= 3;
}

message TransInput {
	required string from			= 1;
	required uint64 amount			= 2;
	required bytes sig				= 3;
}

// TODO: do we need a transID?
// ledgerIndex should increase the ledger coherence
message Transaction {
	required bytes transID			= 1;
	repeated bytes from				= 2;
	required bytes dest				= 3;
	required uint64 amount			= 4;
	required uint64 ledgerIndex		= 5;
	required int32 seqNum			= 6;
	required bytes pubKey			= 7;
	required bytes sig				= 8;
}

// Sequence number is incremented if you must change the ledger that you are validating
// You will only need to change validation in cases of incompatible ledgers 
message Validation {
	required uint64 ledgerIndex		= 1;
	required string hash			= 2;
	required string hanko			= 3;
	required int32 seqNum			= 4;
	required bytes sig				= 5;
}

message Account {
	required bytes address			= 1;
	required uint64 amount			= 2;
	required uint32 seqNum			= 3;
}

// The ledger hash includes:
// index,accounts,feeHeld,transactions?
message FullLedger {
	required uint64 index				= 1;
	required bytes hash					= 2;
	required bytes parentHash			= 3;
	required uint64 feeHeld				= 4;
	repeated Account accounts			= 5;
	repeated Transaction transactions	= 6;
}


message GetFullLedger {
	required uint64 ledgerIndex		= 1;
	optional bytes hash				= 2;
}

message GetValidations {
	required uint64 ledgerIndex		= 1;
}

message Contact {
	required string nodeID			= 1;
	required string nodeIP			= 2;
	required int32 port				= 3;
}

// I thought about adding a hash of the transactions here so you know if the difference is 
// due to a different set of transactions or to a different parent
// but I think the times this will happen are very rare so it's probably not worth it
// but it might be worth also sending a hash of the accounts since if these match you don't care that the transactions don't
message ProposeLedger {
	required uint64 ledgerIndex		= 1;
	required bytes hash				= 2;
	optional uint64 numTransactions	= 3;
}

message ErrorMsg {
	optional int32 errorCode		= 1;
	optional string message			= 2;
}
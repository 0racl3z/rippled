package newcoin;

enum MessageType {
// core
	mtHELLO=				1;
	mtERROR_MSG=			2;
	mtPING=					3;

// network presence detection
	mtGET_CONTACTS=			10;
	mtCONTACT=				11;

// operations for 'small' nodes
	mtSEARCH_TRANSACTION=	20;
	mtGET_ACCOUNT=			21;
	mtACCOUNT=				22;

// transaction and ledger processing
	mtTRANSACTION=			30;
	mtGET_LEDGER=			31;
	mtLEDGER_DATA=			32;
	mtPROPOSE_LEDGER=		33;
	mtSTATUS_CHANGE=		34;
	mtHAVE_SET=				35;

// data replication and synchronization
	mtGET_VALIDATIONS=		40;
	mtVALIDATION=			41;
	mtGET_OBJECT=			42;
	mtOBJECT=				43;
}


// Sent on connect


message TMHello {
	required uint32 version				= 1;
	optional uint32 ledgerIndex			= 2;
	optional uint64 netTime				= 3;
	optional bytes	nodePublic			= 4; // node may opt to remain anonymous
	optional bytes	nodeProof			= 5;
	optional uint32 ipv4Port			= 6;
	optional bytes	closedLedger 		= 7; // our last closed ledger
	optional bytes	previousLedger		= 8; // the ledger before the last closed ledger
}


/*
A transaction can have only one input and one output.
If you want to send an amount that is greater than any single address of yours
you must first combine coins from one address to another.
*/

enum TransactionStatus {
	tsNEW				= 1;	// origin node did/could not validate
	tsCURRENT			= 2;	// scheduled to go in this ledger
	tsCOMMITED			= 3;	// in a closed ledger
	tsREJECT_CONFLICT	= 4;
	tsREJECT_INVALID	= 5;
	tsREJECT_FUNDS		= 6;
	tsHELD_SEQ			= 7;
	tsHELD_LEDGER		= 8;	// held for future ledger
}

message TMTransaction {
	required bytes rawTransaction		= 1;
	required TransactionStatus status	= 9;
	optional uint64 receiveTimestamp	= 10;
	optional uint32 ledgerIndexPossible	= 11; // the node may not know
	optional uint32 ledgerIndexFinal	= 12;
	optional bytes conflictingTransaction	= 13;
}



enum NodeStatus {
	nsCONNECTING	= 1;		// acquiring connections
	nsCONNECTED		= 2;		// convinced we are connected to the real network
	nsMONITORING	= 3;		// we know what the previous ledger is
	nsVALIDATING	= 4;		// we have the full ledger contents
	nsSHUTTING		= 5;		// node is shutting down
}

enum NodeEvent {
	neCLOSING_LEDGER	= 1;	// closing a ledger because its close time has come
	neACCEPTED_LEDGER	= 2;	// accepting a closed ledger, we have finished computing it
	neSWITCHED_LEDGER	= 3;	// changing due to network consensus
}

message TMStatusChange {
	optional NodeStatus newStatus		= 1;
	optional NodeEvent newEvent			= 2;
	optional uint32 ledgerSeq			= 3;
	optional bytes ledgerHash			= 4;
	optional bytes previousLedgerHash	= 5;
	optional uint64 networkTime			= 6;
}


// Announce to the network our position on a closing ledger
message TMProposeSet {
	required bytes prevClosedHash		= 1;
	required uint32 proposeSeq			= 2;
	required bytes currentTxHash		= 3;	// the hash of the ledger we are proposing
	required bytes nodePubKey			= 4;
	required bytes signature			= 5;	// signature of above fields
	repeated bytes addedTransactions	= 6;	// not required if number is large
	repeated bytes removedTransactions	= 7;	// not required if number is large
}

// Announce to a peer that we have fully acquired a transaction set
message TMHaveTransactionSet {
	repeated bytes hashes				= 1;
}


// Used to sign a final closed ledger after reprocessing
message TMValidation {
	required bytes validation		= 1;		// in SerializedValidation signed form
}


message TMGetValidations {
	required uint32 ledgerIndex		= 1;
	repeated bytes hanko			= 2;
	optional uint32 count			= 3; // get random validations
}



message TMContact {
	required bytes pubKey				= 1;
	required uint32 softwareVersion		= 2;
	required uint32 protoVersion		= 3;
	required uint64 nodeFlags			= 4;
	required uint64 timestamp			= 5;
	repeated bytes nodeInfo				= 6;
	required bytes signature			= 7;
}

// request node information
message TMGetContacts {
	repeated bytes nodeIDs			=1; // specific nodes we want
	optional uint32 nodeCount		=2; // get some random nodes
}


message TMSearchTransaction {
	required uint32 maxTrans	=1;
	optional bytes toAccount	=2;
	optional bytes fromAccount	=3;
	optional uint32	minLedger	=4;
	optional bytes fromAcctSeq	=5;
	repeated bytes transID		=6;
}

message TMGetAccount {
	repeated bytes acctID		=1;
	optional uint32 seq			=2;
}

message Account {
	required bytes accountID	=1;
	required uint64 balance		=2;
	required uint32 accountSeq	=3;
	required uint32 ledgerSeq	=4;
}

message TMAccount{
	repeated Account accounts	=1;
	optional uint32 seq			=2;
}

message TMIndexedObject
{
	enum ObjectType {
		otTRANSACTION			= 1;
		otTRANSACTION_NODE		= 2; // a node in a transaction tree
		otTRANSACTION_LEAF		= 3; // a leaf in a transaction tree
		otACCOUNT				= 4; // a single account state (with balance/sequence)
		otACCOUNT_NODE			= 5; // a node in an account state tree
		otACCOUNT_LEAF			= 6; // a leaf in an account state tree
		otLEDGER				= 7;
	}

	required bytes hash			= 1;
	required ObjectType type	= 2;
}



message TMGetObjectByHash
{
	required TMIndexedObject object	= 1;
	optional uint32 seq				= 2;	// used to match replies to queries
}

message TMObjectByHash
{
	optional TMIndexedObject object	= 1;	// present unless no object found
	optional bytes data				= 2;	// present unless no object found
	optional uint32 seq				= 3;	// matches seq from query
}

message TMLedgerNode {
	required bytes nodeid			= 1;
	required bytes nodedata			= 2;
}

enum TMLedgerInfoType {
	liBASE	= 0;		// basic ledger info
	liTX_NODE = 1;		// transaction node
	liAS_NODE = 2;		// account state node
	liTS_CANDIDATE = 3; // candidate transaction set
}

enum TMLedgerType {
	ltACCEPTED = 0;
	ltCURRENT  = 1;
	ltCLOSED   = 2;
}

message TMGetLedger {
	optional TMLedgerType ltype		= 1;
	optional bytes ledgerHash		= 2;	// Can also be the transaction set hash if liTS_CANDIDATE
	optional uint32 ledgerSeq		= 3;
	required TMLedgerInfoType itype	= 4;
	repeated bytes nodeIDs			= 5;
}

message TMLedgerData {
	required bytes ledgerHash		= 1;
	required uint32 ledgerSeq		= 2;
	required TMLedgerInfoType type	= 3;
	repeated TMLedgerNode nodes		= 4;
}


message TMPing {
	enum pingType {
		PING = 0; // we want a reply
		PONG = 1; // this is a reply
	}
	required pingType type		= 1;
	optional uint32 seq			= 2; // detect stale replies, ensure other side is reading
	optional uint64 pingTime	= 3; // know when we think we sent the ping
	optional uint64 netTime		= 4;
}


message TMErrorMsg {
	optional int32 errorCode	= 1;
	optional string message		= 2;
}
// vim:ts=4

package newcoin;

enum MessageType {
// core
	mtHELLO					= 1;
	mtERROR_MSG				= 2;
	mtPING					= 3;

// network presence detection
	mtGET_CONTACTS			= 10;
	mtCONTACT				= 11;
	mtGET_PEERS				= 12;
	mtPEERS					= 13;

// operations for 'small' nodes
	mtSEARCH_TRANSACTION	= 20;
	mtGET_ACCOUNT			= 21;
	mtACCOUNT				= 22;

// transaction and ledger processing
	mtTRANSACTION			= 30;
	mtGET_LEDGER			= 31;
	mtLEDGER_DATA			= 32;
	mtPROPOSE_LEDGER		= 33;
	mtSTATUS_CHANGE			= 34;
	mtHAVE_SET				= 35;

// data replication and synchronization
	mtGET_VALIDATIONS		= 40;
	mtVALIDATION			= 41;
	mtGET_OBJECT			= 42;
	mtOBJECT				= 43;
}


// Sent on connect


message TMHello {
	required uint32 protoVersion			= 1;
	required uint32 protoVersionMin			= 2;
	required bytes	nodePublic				= 3;
	required bytes	nodeProof				= 4;
	optional string fullVersion				= 5;
	optional uint64 netTime					= 6;
	optional uint32 ipv4Port				= 7;
	optional uint32 ledgerIndex				= 8;
	optional bytes	ledgerClosed 			= 9;  // our last closed ledger
	optional bytes	ledgerPrevious			= 10; // the ledger before the last closed ledger
}


// A transaction can have only one input and one output.
// If you want to send an amount that is greater than any single address of yours
// you must first combine coins from one address to another.

enum TransactionStatus {
	tsNEW				= 1;	// origin node did/could not validate
	tsCURRENT			= 2;	// scheduled to go in this ledger
	tsCOMMITED			= 3;	// in a closed ledger
	tsREJECT_CONFLICT	= 4;
	tsREJECT_INVALID	= 5;
	tsREJECT_FUNDS		= 6;
	tsHELD_SEQ			= 7;
	tsHELD_LEDGER		= 8;	// held for future ledger
}

message TMTransaction {
	required bytes rawTransaction			= 1;
	required TransactionStatus status		= 2;
	optional uint64 receiveTimestamp		= 3;
	optional uint32 ledgerIndexPossible		= 4; // the node may not know
	optional uint32 ledgerIndexFinal		= 5;
	optional bytes conflictingTransaction	= 6;
}


enum NodeStatus {
	nsCONNECTING	= 1;		// acquiring connections
	nsCONNECTED		= 2;		// convinced we are connected to the real network
	nsMONITORING	= 3;		// we know what the previous ledger is
	nsVALIDATING	= 4;		// we have the full ledger contents
	nsSHUTTING		= 5;		// node is shutting down
}

enum NodeEvent {
	neCLOSING_LEDGER	= 1;	// closing a ledger because its close time has come
	neACCEPTED_LEDGER	= 2;	// accepting a closed ledger, we have finished computing it
	neSWITCHED_LEDGER	= 3;	// changing due to network consensus
	neLOST_SYNC			= 4;
}

message TMStatusChange {
	optional NodeStatus newStatus		= 1;
	optional NodeEvent newEvent			= 2;
	optional uint32 ledgerSeq			= 3;
	optional bytes ledgerHash			= 4;
	optional bytes ledgerHashPrevious	= 5;
	optional uint64 networkTime			= 6;
}


// Announce to the network our position on a closing ledger
message TMProposeSet {
	required uint32 proposeSeq			= 1;
	required bytes currentTxHash		= 2;	// the hash of the ledger we are proposing
	required bytes nodePubKey			= 3;
	required uint64 closeTime			= 4;
	required bytes signature			= 5;	// signature of above fields
	repeated bytes addedTransactions	= 6;	// not required if number is large
	repeated bytes removedTransactions	= 7;	// not required if number is large
}

enum TxSetStatus {
	tsHAVE		= 1;	// We have this set locally
	tsCAN_GET	= 2;	// We have a peer with this set
	tsNEED		= 3;	// We need this set and can't get it
}

message TMHaveTransactionSet {
	required TxSetStatus status		= 1;
	required bytes hash				= 2;
}


// Used to sign a final closed ledger after reprocessing
message TMValidation {
	required bytes validation		= 1;		// in SerializedValidation signed form
}


message TMGetValidations {
	required uint32 ledgerIndex		= 1;
	repeated bytes hanko			= 2;
	optional uint32 count			= 3; // get random validations
}



message TMContact {
	required bytes pubKey				= 1;
	required uint32 softwareVersion		= 2;
	required uint32 protoVersion		= 3;
	required uint64 nodeFlags			= 4;
	required uint64 timestamp			= 5;
	repeated bytes nodeInfo				= 6;
	required bytes signature			= 7;
}

// request node information
message TMGetContacts {
	repeated bytes nodeIDs			= 1; // specific nodes we want
	optional uint32 nodeCount		= 2; // get some random nodes
}

message TMGetPeers {
	required uint32 doWeNeedThis	= 1;  // yes since you are asserting that the packet size isn't 0 in PackedMessage
}

message TMIPv4EndPoint {
	required uint32 ipv4			= 1;
	required uint32 ipv4Port		= 2;
}

message TMPeers {
	repeated TMIPv4EndPoint nodes	= 1;
}


message TMSearchTransaction {
	required uint32 maxTrans	= 1;
	optional bytes toAccount	= 2;
	optional bytes fromAccount	= 3;
	optional uint32	minLedger	= 4;
	optional bytes fromAcctSeq	= 5;
	repeated bytes transID		= 6;
}

message TMGetAccount {
	repeated bytes acctID		= 1;
	optional uint32 seq			= 2;
}

message Account {
	required bytes accountID	= 1;
	required uint64 balance		= 2;
	required uint32 accountSeq	= 3;
	required uint32 ledgerSeq	= 4;
}

message TMAccount{
	repeated Account accounts	= 1;
	optional uint32 seq			= 2;
}

message TMIndexedObject
{
	enum ObjectType {
		otTRANSACTION			= 1;
		otTRANSACTION_NODE		= 2; // a node in a transaction tree
		otTRANSACTION_LEAF		= 3; // a leaf in a transaction tree
		otACCOUNT				= 4; // a single account state (with balance/sequence)
		otACCOUNT_NODE			= 5; // a node in an account state tree
		otACCOUNT_LEAF			= 6; // a leaf in an account state tree
		otLEDGER				= 7;
	}

	required bytes hash			= 1;
	required ObjectType type	= 2;
}



message TMGetObjectByHash
{
	required TMIndexedObject object	= 1;
	optional uint32 seq				= 2;	// used to match replies to queries
}

message TMObjectByHash
{
	optional TMIndexedObject object	= 1;	// present unless no object found
	optional bytes data				= 2;	// present unless no object found
	optional uint32 seq				= 3;	// matches seq from query
}

message TMLedgerNode {
	required bytes nodedata			= 1;
	optional bytes nodeid			= 2;	// missing for ledger base data
}

enum TMLedgerInfoType {
	liBASE			= 0;		// basic ledger info
	liTX_NODE		= 1;		// transaction node
	liAS_NODE		= 2;		// account state node
	liTS_CANDIDATE	= 3;		// candidate transaction set
}

enum TMLedgerType {
	ltACCEPTED		= 0;
	ltCURRENT  		= 1;
	ltCLOSED   		= 2;
}

message TMGetLedger {
	required TMLedgerInfoType itype	= 1;
	optional TMLedgerType ltype		= 2;
	optional bytes ledgerHash		= 3;	// Can also be the transaction set hash if liTS_CANDIDATE
	optional uint32 ledgerSeq		= 4;
	repeated bytes nodeIDs			= 5;
	optional uint32 requestCookie	= 6;
}

message TMLedgerData {
	required bytes ledgerHash		= 1;
	required uint32 ledgerSeq		= 2;
	required TMLedgerInfoType type	= 3;
	repeated TMLedgerNode nodes		= 4;
	optional uint32 requestCookie	= 5;
}


message TMPing {
	enum pingType {
		PING = 0; // we want a reply
		PONG = 1; // this is a reply
	}
	required pingType type		= 1;
	optional uint32 seq			= 2; // detect stale replies, ensure other side is reading
	optional uint64 pingTime	= 3; // know when we think we sent the ping
	optional uint64 netTime		= 4;
}


message TMErrorMsg {
	optional int32 errorCode	= 1;
	optional string message		= 2;
}

// vim:ts=4

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: newcoin.proto

#ifndef PROTOBUF_newcoin_2eproto__INCLUDED
#define PROTOBUF_newcoin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace newcoin {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_newcoin_2eproto();
void protobuf_AssignDesc_newcoin_2eproto();
void protobuf_ShutdownFile_newcoin_2eproto();

class Hello;
class Transaction;
class Validation;
class Account;
class FullLedger;
class GetFullLedger;
class GetValidations;
class Contact;
class Contact_NodeInfo;
class Contact_ContactInfo;
class GetContacts;
class ProposeLedger;
class Ping;
class ErrorMsg;

enum Contact_NodeInfo_infoType {
  Contact_NodeInfo_infoType_ORG_NAME = 0,
  Contact_NodeInfo_infoType_NODE_NAME = 1,
  Contact_NodeInfo_infoType_URL = 2,
  Contact_NodeInfo_infoType_ADMIN_EMAIL = 3,
  Contact_NodeInfo_infoType_NODE_POLICY = 4
};
bool Contact_NodeInfo_infoType_IsValid(int value);
const Contact_NodeInfo_infoType Contact_NodeInfo_infoType_infoType_MIN = Contact_NodeInfo_infoType_ORG_NAME;
const Contact_NodeInfo_infoType Contact_NodeInfo_infoType_infoType_MAX = Contact_NodeInfo_infoType_NODE_POLICY;
const int Contact_NodeInfo_infoType_infoType_ARRAYSIZE = Contact_NodeInfo_infoType_infoType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Contact_NodeInfo_infoType_descriptor();
inline const ::std::string& Contact_NodeInfo_infoType_Name(Contact_NodeInfo_infoType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Contact_NodeInfo_infoType_descriptor(), value);
}
inline bool Contact_NodeInfo_infoType_Parse(
    const ::std::string& name, Contact_NodeInfo_infoType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Contact_NodeInfo_infoType>(
    Contact_NodeInfo_infoType_descriptor(), name, value);
}
enum Ping_pingType {
  Ping_pingType_PING = 0,
  Ping_pingType_PONG = 1
};
bool Ping_pingType_IsValid(int value);
const Ping_pingType Ping_pingType_pingType_MIN = Ping_pingType_PING;
const Ping_pingType Ping_pingType_pingType_MAX = Ping_pingType_PONG;
const int Ping_pingType_pingType_ARRAYSIZE = Ping_pingType_pingType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Ping_pingType_descriptor();
inline const ::std::string& Ping_pingType_Name(Ping_pingType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Ping_pingType_descriptor(), value);
}
inline bool Ping_pingType_Parse(
    const ::std::string& name, Ping_pingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Ping_pingType>(
    Ping_pingType_descriptor(), name, value);
}
enum Type {
  HELLO = 1,
  TRANSACTION = 2,
  FULL_LEDGER = 3,
  VALIDATION = 4,
  PROPOSE_LEDGER = 5,
  GET_FULL_LEDGER = 6,
  GET_VALIDATIONS = 7,
  GET_CONTACTS = 8,
  CONTACT = 9,
  PING = 10,
  ERROR_MSG = 11
};
bool Type_IsValid(int value);
const Type Type_MIN = HELLO;
const Type Type_MAX = ERROR_MSG;
const int Type_ARRAYSIZE = Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Type_descriptor();
inline const ::std::string& Type_Name(Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Type_descriptor(), value);
}
inline bool Type_Parse(
    const ::std::string& name, Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
enum TransactionStatus {
  ACCEPTED = 1,
  INVALID = 2,
  INSUFFICIENT_FUNDS = 3,
  INSUFFICIENT_FEE = 4,
  CONFLICTED = 5,
  HELD = 6
};
bool TransactionStatus_IsValid(int value);
const TransactionStatus TransactionStatus_MIN = ACCEPTED;
const TransactionStatus TransactionStatus_MAX = HELD;
const int TransactionStatus_ARRAYSIZE = TransactionStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransactionStatus_descriptor();
inline const ::std::string& TransactionStatus_Name(TransactionStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransactionStatus_descriptor(), value);
}
inline bool TransactionStatus_Parse(
    const ::std::string& name, TransactionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransactionStatus>(
    TransactionStatus_descriptor(), name, value);
}
// ===================================================================

class Hello : public ::google::protobuf::Message {
 public:
  Hello();
  virtual ~Hello();
  
  Hello(const Hello& from);
  
  inline Hello& operator=(const Hello& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Hello& default_instance();
  
  void Swap(Hello* other);
  
  // implements Message ----------------------------------------------
  
  Hello* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hello& from);
  void MergeFrom(const Hello& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // required bytes nodeID = 2;
  inline bool has_nodeid() const;
  inline void clear_nodeid();
  static const int kNodeIDFieldNumber = 2;
  inline const ::std::string& nodeid() const;
  inline void set_nodeid(const ::std::string& value);
  inline void set_nodeid(const char* value);
  inline void set_nodeid(const void* value, size_t size);
  inline ::std::string* mutable_nodeid();
  inline ::std::string* release_nodeid();
  
  // required bytes pubKey = 3;
  inline bool has_pubkey() const;
  inline void clear_pubkey();
  static const int kPubKeyFieldNumber = 3;
  inline const ::std::string& pubkey() const;
  inline void set_pubkey(const ::std::string& value);
  inline void set_pubkey(const char* value);
  inline void set_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_pubkey();
  inline ::std::string* release_pubkey();
  
  // required int32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // optional int32 yourIP = 5;
  inline bool has_yourip() const;
  inline void clear_yourip();
  static const int kYourIPFieldNumber = 5;
  inline ::google::protobuf::int32 yourip() const;
  inline void set_yourip(::google::protobuf::int32 value);
  
  // optional int64 netTime = 6;
  inline bool has_nettime() const;
  inline void clear_nettime();
  static const int kNetTimeFieldNumber = 6;
  inline ::google::protobuf::int64 nettime() const;
  inline void set_nettime(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:newcoin.Hello)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_nodeid();
  inline void clear_has_nodeid();
  inline void set_has_pubkey();
  inline void clear_has_pubkey();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_yourip();
  inline void clear_has_yourip();
  inline void set_has_nettime();
  inline void clear_has_nettime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nodeid_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 port_;
  ::std::string* pubkey_;
  ::google::protobuf::int64 nettime_;
  ::google::protobuf::int32 yourip_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static Hello* default_instance_;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message {
 public:
  Transaction();
  virtual ~Transaction();
  
  Transaction(const Transaction& from);
  
  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();
  
  void Swap(Transaction* other);
  
  // implements Message ----------------------------------------------
  
  Transaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const void* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  
  // required bytes dest = 2;
  inline bool has_dest() const;
  inline void clear_dest();
  static const int kDestFieldNumber = 2;
  inline const ::std::string& dest() const;
  inline void set_dest(const ::std::string& value);
  inline void set_dest(const char* value);
  inline void set_dest(const void* value, size_t size);
  inline ::std::string* mutable_dest();
  inline ::std::string* release_dest();
  
  // required uint64 amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);
  
  // required uint32 sourceLedgerIndex = 4;
  inline bool has_sourceledgerindex() const;
  inline void clear_sourceledgerindex();
  static const int kSourceLedgerIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 sourceledgerindex() const;
  inline void set_sourceledgerindex(::google::protobuf::uint32 value);
  
  // required uint32 seqNum = 5;
  inline bool has_seqnum() const;
  inline void clear_seqnum();
  static const int kSeqNumFieldNumber = 5;
  inline ::google::protobuf::uint32 seqnum() const;
  inline void set_seqnum(::google::protobuf::uint32 value);
  
  // required uint32 ident = 6;
  inline bool has_ident() const;
  inline void clear_ident();
  static const int kIdentFieldNumber = 6;
  inline ::google::protobuf::uint32 ident() const;
  inline void set_ident(::google::protobuf::uint32 value);
  
  // required bytes pubKey = 7;
  inline bool has_pubkey() const;
  inline void clear_pubkey();
  static const int kPubKeyFieldNumber = 7;
  inline const ::std::string& pubkey() const;
  inline void set_pubkey(const ::std::string& value);
  inline void set_pubkey(const char* value);
  inline void set_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_pubkey();
  inline ::std::string* release_pubkey();
  
  // required bytes sig = 8;
  inline bool has_sig() const;
  inline void clear_sig();
  static const int kSigFieldNumber = 8;
  inline const ::std::string& sig() const;
  inline void set_sig(const ::std::string& value);
  inline void set_sig(const char* value);
  inline void set_sig(const void* value, size_t size);
  inline ::std::string* mutable_sig();
  inline ::std::string* release_sig();
  
  // optional .newcoin.TransactionStatus status = 9;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 9;
  inline newcoin::TransactionStatus status() const;
  inline void set_status(newcoin::TransactionStatus value);
  
  // optional uint32 ledgerIndex = 10;
  inline bool has_ledgerindex() const;
  inline void clear_ledgerindex();
  static const int kLedgerIndexFieldNumber = 10;
  inline ::google::protobuf::uint32 ledgerindex() const;
  inline void set_ledgerindex(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:newcoin.Transaction)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_dest();
  inline void clear_has_dest();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_sourceledgerindex();
  inline void clear_has_sourceledgerindex();
  inline void set_has_seqnum();
  inline void clear_has_seqnum();
  inline void set_has_ident();
  inline void clear_has_ident();
  inline void set_has_pubkey();
  inline void clear_has_pubkey();
  inline void set_has_sig();
  inline void clear_has_sig();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_ledgerindex();
  inline void clear_has_ledgerindex();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* from_;
  ::std::string* dest_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint32 sourceledgerindex_;
  ::google::protobuf::uint32 seqnum_;
  ::std::string* pubkey_;
  ::google::protobuf::uint32 ident_;
  int status_;
  ::std::string* sig_;
  ::google::protobuf::uint32 ledgerindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static Transaction* default_instance_;
};
// -------------------------------------------------------------------

class Validation : public ::google::protobuf::Message {
 public:
  Validation();
  virtual ~Validation();
  
  Validation(const Validation& from);
  
  inline Validation& operator=(const Validation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Validation& default_instance();
  
  void Swap(Validation* other);
  
  // implements Message ----------------------------------------------
  
  Validation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Validation& from);
  void MergeFrom(const Validation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 ledgerIndex = 1;
  inline bool has_ledgerindex() const;
  inline void clear_ledgerindex();
  static const int kLedgerIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 ledgerindex() const;
  inline void set_ledgerindex(::google::protobuf::uint32 value);
  
  // required bytes hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  
  // required bytes hanko = 3;
  inline bool has_hanko() const;
  inline void clear_hanko();
  static const int kHankoFieldNumber = 3;
  inline const ::std::string& hanko() const;
  inline void set_hanko(const ::std::string& value);
  inline void set_hanko(const char* value);
  inline void set_hanko(const void* value, size_t size);
  inline ::std::string* mutable_hanko();
  inline ::std::string* release_hanko();
  
  // required int32 seqNum = 4;
  inline bool has_seqnum() const;
  inline void clear_seqnum();
  static const int kSeqNumFieldNumber = 4;
  inline ::google::protobuf::int32 seqnum() const;
  inline void set_seqnum(::google::protobuf::int32 value);
  
  // required bytes sig = 5;
  inline bool has_sig() const;
  inline void clear_sig();
  static const int kSigFieldNumber = 5;
  inline const ::std::string& sig() const;
  inline void set_sig(const ::std::string& value);
  inline void set_sig(const char* value);
  inline void set_sig(const void* value, size_t size);
  inline ::std::string* mutable_sig();
  inline ::std::string* release_sig();
  
  // @@protoc_insertion_point(class_scope:newcoin.Validation)
 private:
  inline void set_has_ledgerindex();
  inline void clear_has_ledgerindex();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_hanko();
  inline void clear_has_hanko();
  inline void set_has_seqnum();
  inline void clear_has_seqnum();
  inline void set_has_sig();
  inline void clear_has_sig();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* hash_;
  ::google::protobuf::uint32 ledgerindex_;
  ::google::protobuf::int32 seqnum_;
  ::std::string* hanko_;
  ::std::string* sig_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static Validation* default_instance_;
};
// -------------------------------------------------------------------

class Account : public ::google::protobuf::Message {
 public:
  Account();
  virtual ~Account();
  
  Account(const Account& from);
  
  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();
  
  void Swap(Account* other);
  
  // implements Message ----------------------------------------------
  
  Account* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const void* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  
  // required uint64 amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);
  
  // required uint32 seqNum = 3;
  inline bool has_seqnum() const;
  inline void clear_seqnum();
  static const int kSeqNumFieldNumber = 3;
  inline ::google::protobuf::uint32 seqnum() const;
  inline void set_seqnum(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:newcoin.Account)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_seqnum();
  inline void clear_has_seqnum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* address_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint32 seqnum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static Account* default_instance_;
};
// -------------------------------------------------------------------

class FullLedger : public ::google::protobuf::Message {
 public:
  FullLedger();
  virtual ~FullLedger();
  
  FullLedger(const FullLedger& from);
  
  inline FullLedger& operator=(const FullLedger& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FullLedger& default_instance();
  
  void Swap(FullLedger* other);
  
  // implements Message ----------------------------------------------
  
  FullLedger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FullLedger& from);
  void MergeFrom(const FullLedger& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);
  
  // required bytes hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  
  // required bytes parentHash = 3;
  inline bool has_parenthash() const;
  inline void clear_parenthash();
  static const int kParentHashFieldNumber = 3;
  inline const ::std::string& parenthash() const;
  inline void set_parenthash(const ::std::string& value);
  inline void set_parenthash(const char* value);
  inline void set_parenthash(const void* value, size_t size);
  inline ::std::string* mutable_parenthash();
  inline ::std::string* release_parenthash();
  
  // required uint64 feeHeld = 4;
  inline bool has_feeheld() const;
  inline void clear_feeheld();
  static const int kFeeHeldFieldNumber = 4;
  inline ::google::protobuf::uint64 feeheld() const;
  inline void set_feeheld(::google::protobuf::uint64 value);
  
  // repeated .newcoin.Account accounts = 5;
  inline int accounts_size() const;
  inline void clear_accounts();
  static const int kAccountsFieldNumber = 5;
  inline const ::newcoin::Account& accounts(int index) const;
  inline ::newcoin::Account* mutable_accounts(int index);
  inline ::newcoin::Account* add_accounts();
  inline const ::google::protobuf::RepeatedPtrField< ::newcoin::Account >&
      accounts() const;
  inline ::google::protobuf::RepeatedPtrField< ::newcoin::Account >*
      mutable_accounts();
  
  // repeated .newcoin.Transaction transactions = 6;
  inline int transactions_size() const;
  inline void clear_transactions();
  static const int kTransactionsFieldNumber = 6;
  inline const ::newcoin::Transaction& transactions(int index) const;
  inline ::newcoin::Transaction* mutable_transactions(int index);
  inline ::newcoin::Transaction* add_transactions();
  inline const ::google::protobuf::RepeatedPtrField< ::newcoin::Transaction >&
      transactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::newcoin::Transaction >*
      mutable_transactions();
  
  // @@protoc_insertion_point(class_scope:newcoin.FullLedger)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_parenthash();
  inline void clear_has_parenthash();
  inline void set_has_feeheld();
  inline void clear_has_feeheld();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* hash_;
  ::std::string* parenthash_;
  ::google::protobuf::uint64 feeheld_;
  ::google::protobuf::RepeatedPtrField< ::newcoin::Account > accounts_;
  ::google::protobuf::RepeatedPtrField< ::newcoin::Transaction > transactions_;
  ::google::protobuf::uint32 index_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static FullLedger* default_instance_;
};
// -------------------------------------------------------------------

class GetFullLedger : public ::google::protobuf::Message {
 public:
  GetFullLedger();
  virtual ~GetFullLedger();
  
  GetFullLedger(const GetFullLedger& from);
  
  inline GetFullLedger& operator=(const GetFullLedger& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFullLedger& default_instance();
  
  void Swap(GetFullLedger* other);
  
  // implements Message ----------------------------------------------
  
  GetFullLedger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFullLedger& from);
  void MergeFrom(const GetFullLedger& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes hash = 1;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 1;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  
  // @@protoc_insertion_point(class_scope:newcoin.GetFullLedger)
 private:
  inline void set_has_hash();
  inline void clear_has_hash();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* hash_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static GetFullLedger* default_instance_;
};
// -------------------------------------------------------------------

class GetValidations : public ::google::protobuf::Message {
 public:
  GetValidations();
  virtual ~GetValidations();
  
  GetValidations(const GetValidations& from);
  
  inline GetValidations& operator=(const GetValidations& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetValidations& default_instance();
  
  void Swap(GetValidations* other);
  
  // implements Message ----------------------------------------------
  
  GetValidations* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetValidations& from);
  void MergeFrom(const GetValidations& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 ledgerIndex = 1;
  inline bool has_ledgerindex() const;
  inline void clear_ledgerindex();
  static const int kLedgerIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 ledgerindex() const;
  inline void set_ledgerindex(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:newcoin.GetValidations)
 private:
  inline void set_has_ledgerindex();
  inline void clear_has_ledgerindex();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 ledgerindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static GetValidations* default_instance_;
};
// -------------------------------------------------------------------

class Contact_NodeInfo : public ::google::protobuf::Message {
 public:
  Contact_NodeInfo();
  virtual ~Contact_NodeInfo();
  
  Contact_NodeInfo(const Contact_NodeInfo& from);
  
  inline Contact_NodeInfo& operator=(const Contact_NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Contact_NodeInfo& default_instance();
  
  void Swap(Contact_NodeInfo* other);
  
  // implements Message ----------------------------------------------
  
  Contact_NodeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Contact_NodeInfo& from);
  void MergeFrom(const Contact_NodeInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Contact_NodeInfo_infoType infoType;
  static const infoType ORG_NAME = Contact_NodeInfo_infoType_ORG_NAME;
  static const infoType NODE_NAME = Contact_NodeInfo_infoType_NODE_NAME;
  static const infoType URL = Contact_NodeInfo_infoType_URL;
  static const infoType ADMIN_EMAIL = Contact_NodeInfo_infoType_ADMIN_EMAIL;
  static const infoType NODE_POLICY = Contact_NodeInfo_infoType_NODE_POLICY;
  static inline bool infoType_IsValid(int value) {
    return Contact_NodeInfo_infoType_IsValid(value);
  }
  static const infoType infoType_MIN =
    Contact_NodeInfo_infoType_infoType_MIN;
  static const infoType infoType_MAX =
    Contact_NodeInfo_infoType_infoType_MAX;
  static const int infoType_ARRAYSIZE =
    Contact_NodeInfo_infoType_infoType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  infoType_descriptor() {
    return Contact_NodeInfo_infoType_descriptor();
  }
  static inline const ::std::string& infoType_Name(infoType value) {
    return Contact_NodeInfo_infoType_Name(value);
  }
  static inline bool infoType_Parse(const ::std::string& name,
      infoType* value) {
    return Contact_NodeInfo_infoType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .newcoin.Contact.NodeInfo.infoType NItype = 1;
  inline bool has_nitype() const;
  inline void clear_nitype();
  static const int kNItypeFieldNumber = 1;
  inline ::newcoin::Contact_NodeInfo_infoType nitype() const;
  inline void set_nitype(::newcoin::Contact_NodeInfo_infoType value);
  
  // required string NIvalue = 2;
  inline bool has_nivalue() const;
  inline void clear_nivalue();
  static const int kNIvalueFieldNumber = 2;
  inline const ::std::string& nivalue() const;
  inline void set_nivalue(const ::std::string& value);
  inline void set_nivalue(const char* value);
  inline void set_nivalue(const char* value, size_t size);
  inline ::std::string* mutable_nivalue();
  inline ::std::string* release_nivalue();
  
  // @@protoc_insertion_point(class_scope:newcoin.Contact.NodeInfo)
 private:
  inline void set_has_nitype();
  inline void clear_has_nitype();
  inline void set_has_nivalue();
  inline void clear_has_nivalue();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nivalue_;
  int nitype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static Contact_NodeInfo* default_instance_;
};
// -------------------------------------------------------------------

class Contact_ContactInfo : public ::google::protobuf::Message {
 public:
  Contact_ContactInfo();
  virtual ~Contact_ContactInfo();
  
  Contact_ContactInfo(const Contact_ContactInfo& from);
  
  inline Contact_ContactInfo& operator=(const Contact_ContactInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Contact_ContactInfo& default_instance();
  
  void Swap(Contact_ContactInfo* other);
  
  // implements Message ----------------------------------------------
  
  Contact_ContactInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Contact_ContactInfo& from);
  void MergeFrom(const Contact_ContactInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string nodeID = 1;
  inline bool has_nodeid() const;
  inline void clear_nodeid();
  static const int kNodeIDFieldNumber = 1;
  inline const ::std::string& nodeid() const;
  inline void set_nodeid(const ::std::string& value);
  inline void set_nodeid(const char* value);
  inline void set_nodeid(const char* value, size_t size);
  inline ::std::string* mutable_nodeid();
  inline ::std::string* release_nodeid();
  
  // required bytes pubKey = 2;
  inline bool has_pubkey() const;
  inline void clear_pubkey();
  static const int kPubKeyFieldNumber = 2;
  inline const ::std::string& pubkey() const;
  inline void set_pubkey(const ::std::string& value);
  inline void set_pubkey(const char* value);
  inline void set_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_pubkey();
  inline ::std::string* release_pubkey();
  
  // required string nodeIP = 3;
  inline bool has_nodeip() const;
  inline void clear_nodeip();
  static const int kNodeIPFieldNumber = 3;
  inline const ::std::string& nodeip() const;
  inline void set_nodeip(const ::std::string& value);
  inline void set_nodeip(const char* value);
  inline void set_nodeip(const char* value, size_t size);
  inline ::std::string* mutable_nodeip();
  inline ::std::string* release_nodeip();
  
  // repeated string additionalIPs = 4;
  inline int additionalips_size() const;
  inline void clear_additionalips();
  static const int kAdditionalIPsFieldNumber = 4;
  inline const ::std::string& additionalips(int index) const;
  inline ::std::string* mutable_additionalips(int index);
  inline void set_additionalips(int index, const ::std::string& value);
  inline void set_additionalips(int index, const char* value);
  inline void set_additionalips(int index, const char* value, size_t size);
  inline ::std::string* add_additionalips();
  inline void add_additionalips(const ::std::string& value);
  inline void add_additionalips(const char* value);
  inline void add_additionalips(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& additionalips() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_additionalips();
  
  // required int32 port = 5;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 5;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // required int32 protoVersion = 6;
  inline bool has_protoversion() const;
  inline void clear_protoversion();
  static const int kProtoVersionFieldNumber = 6;
  inline ::google::protobuf::int32 protoversion() const;
  inline void set_protoversion(::google::protobuf::int32 value);
  
  // required int32 nodeFlags = 7;
  inline bool has_nodeflags() const;
  inline void clear_nodeflags();
  static const int kNodeFlagsFieldNumber = 7;
  inline ::google::protobuf::int32 nodeflags() const;
  inline void set_nodeflags(::google::protobuf::int32 value);
  
  // repeated .newcoin.Contact.NodeInfo nodeInfo = 8;
  inline int nodeinfo_size() const;
  inline void clear_nodeinfo();
  static const int kNodeInfoFieldNumber = 8;
  inline const ::newcoin::Contact_NodeInfo& nodeinfo(int index) const;
  inline ::newcoin::Contact_NodeInfo* mutable_nodeinfo(int index);
  inline ::newcoin::Contact_NodeInfo* add_nodeinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::newcoin::Contact_NodeInfo >&
      nodeinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::newcoin::Contact_NodeInfo >*
      mutable_nodeinfo();
  
  // optional uint64 timestamp = 9;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 9;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:newcoin.Contact.ContactInfo)
 private:
  inline void set_has_nodeid();
  inline void clear_has_nodeid();
  inline void set_has_pubkey();
  inline void clear_has_pubkey();
  inline void set_has_nodeip();
  inline void clear_has_nodeip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_protoversion();
  inline void clear_has_protoversion();
  inline void set_has_nodeflags();
  inline void clear_has_nodeflags();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nodeid_;
  ::std::string* pubkey_;
  ::std::string* nodeip_;
  ::google::protobuf::RepeatedPtrField< ::std::string> additionalips_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 protoversion_;
  ::google::protobuf::RepeatedPtrField< ::newcoin::Contact_NodeInfo > nodeinfo_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::int32 nodeflags_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static Contact_ContactInfo* default_instance_;
};
// -------------------------------------------------------------------

class Contact : public ::google::protobuf::Message {
 public:
  Contact();
  virtual ~Contact();
  
  Contact(const Contact& from);
  
  inline Contact& operator=(const Contact& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Contact& default_instance();
  
  void Swap(Contact* other);
  
  // implements Message ----------------------------------------------
  
  Contact* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Contact& from);
  void MergeFrom(const Contact& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Contact_NodeInfo NodeInfo;
  typedef Contact_ContactInfo ContactInfo;
  
  // accessors -------------------------------------------------------
  
  // required .newcoin.Contact.ContactInfo nodeInfo = 1;
  inline bool has_nodeinfo() const;
  inline void clear_nodeinfo();
  static const int kNodeInfoFieldNumber = 1;
  inline const ::newcoin::Contact_ContactInfo& nodeinfo() const;
  inline ::newcoin::Contact_ContactInfo* mutable_nodeinfo();
  inline ::newcoin::Contact_ContactInfo* release_nodeinfo();
  
  // required bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  
  // required int32 distance = 3;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 3;
  inline ::google::protobuf::int32 distance() const;
  inline void set_distance(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:newcoin.Contact)
 private:
  inline void set_has_nodeinfo();
  inline void clear_has_nodeinfo();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_distance();
  inline void clear_has_distance();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::newcoin::Contact_ContactInfo* nodeinfo_;
  ::std::string* signature_;
  ::google::protobuf::int32 distance_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static Contact* default_instance_;
};
// -------------------------------------------------------------------

class GetContacts : public ::google::protobuf::Message {
 public:
  GetContacts();
  virtual ~GetContacts();
  
  GetContacts(const GetContacts& from);
  
  inline GetContacts& operator=(const GetContacts& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetContacts& default_instance();
  
  void Swap(GetContacts* other);
  
  // implements Message ----------------------------------------------
  
  GetContacts* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetContacts& from);
  void MergeFrom(const GetContacts& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated bytes nodeIDs = 1;
  inline int nodeids_size() const;
  inline void clear_nodeids();
  static const int kNodeIDsFieldNumber = 1;
  inline const ::std::string& nodeids(int index) const;
  inline ::std::string* mutable_nodeids(int index);
  inline void set_nodeids(int index, const ::std::string& value);
  inline void set_nodeids(int index, const char* value);
  inline void set_nodeids(int index, const void* value, size_t size);
  inline ::std::string* add_nodeids();
  inline void add_nodeids(const ::std::string& value);
  inline void add_nodeids(const char* value);
  inline void add_nodeids(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& nodeids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nodeids();
  
  // optional int32 nodeCount = 2;
  inline bool has_nodecount() const;
  inline void clear_nodecount();
  static const int kNodeCountFieldNumber = 2;
  inline ::google::protobuf::int32 nodecount() const;
  inline void set_nodecount(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:newcoin.GetContacts)
 private:
  inline void set_has_nodecount();
  inline void clear_has_nodecount();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> nodeids_;
  ::google::protobuf::int32 nodecount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static GetContacts* default_instance_;
};
// -------------------------------------------------------------------

class ProposeLedger : public ::google::protobuf::Message {
 public:
  ProposeLedger();
  virtual ~ProposeLedger();
  
  ProposeLedger(const ProposeLedger& from);
  
  inline ProposeLedger& operator=(const ProposeLedger& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProposeLedger& default_instance();
  
  void Swap(ProposeLedger* other);
  
  // implements Message ----------------------------------------------
  
  ProposeLedger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProposeLedger& from);
  void MergeFrom(const ProposeLedger& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 ledgerIndex = 1;
  inline bool has_ledgerindex() const;
  inline void clear_ledgerindex();
  static const int kLedgerIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 ledgerindex() const;
  inline void set_ledgerindex(::google::protobuf::uint32 value);
  
  // required bytes hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  
  // optional uint64 numTransactions = 3;
  inline bool has_numtransactions() const;
  inline void clear_numtransactions();
  static const int kNumTransactionsFieldNumber = 3;
  inline ::google::protobuf::uint64 numtransactions() const;
  inline void set_numtransactions(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:newcoin.ProposeLedger)
 private:
  inline void set_has_ledgerindex();
  inline void clear_has_ledgerindex();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_numtransactions();
  inline void clear_has_numtransactions();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* hash_;
  ::google::protobuf::uint64 numtransactions_;
  ::google::protobuf::uint32 ledgerindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static ProposeLedger* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message {
 public:
  Ping();
  virtual ~Ping();
  
  Ping(const Ping& from);
  
  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();
  
  void Swap(Ping* other);
  
  // implements Message ----------------------------------------------
  
  Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Ping_pingType pingType;
  static const pingType PING = Ping_pingType_PING;
  static const pingType PONG = Ping_pingType_PONG;
  static inline bool pingType_IsValid(int value) {
    return Ping_pingType_IsValid(value);
  }
  static const pingType pingType_MIN =
    Ping_pingType_pingType_MIN;
  static const pingType pingType_MAX =
    Ping_pingType_pingType_MAX;
  static const int pingType_ARRAYSIZE =
    Ping_pingType_pingType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  pingType_descriptor() {
    return Ping_pingType_descriptor();
  }
  static inline const ::std::string& pingType_Name(pingType value) {
    return Ping_pingType_Name(value);
  }
  static inline bool pingType_Parse(const ::std::string& name,
      pingType* value) {
    return Ping_pingType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .newcoin.Ping.pingType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::newcoin::Ping_pingType type() const;
  inline void set_type(::newcoin::Ping_pingType value);
  
  // optional int32 pingVal = 2;
  inline bool has_pingval() const;
  inline void clear_pingval();
  static const int kPingValFieldNumber = 2;
  inline ::google::protobuf::int32 pingval() const;
  inline void set_pingval(::google::protobuf::int32 value);
  
  // optional uint64 pingTime = 3;
  inline bool has_pingtime() const;
  inline void clear_pingtime();
  static const int kPingTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 pingtime() const;
  inline void set_pingtime(::google::protobuf::uint64 value);
  
  // optional uint64 netTime = 4;
  inline bool has_nettime() const;
  inline void clear_nettime();
  static const int kNetTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 nettime() const;
  inline void set_nettime(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:newcoin.Ping)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_pingval();
  inline void clear_has_pingval();
  inline void set_has_pingtime();
  inline void clear_has_pingtime();
  inline void set_has_nettime();
  inline void clear_has_nettime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  ::google::protobuf::int32 pingval_;
  ::google::protobuf::uint64 pingtime_;
  ::google::protobuf::uint64 nettime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class ErrorMsg : public ::google::protobuf::Message {
 public:
  ErrorMsg();
  virtual ~ErrorMsg();
  
  ErrorMsg(const ErrorMsg& from);
  
  inline ErrorMsg& operator=(const ErrorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorMsg& default_instance();
  
  void Swap(ErrorMsg* other);
  
  // implements Message ----------------------------------------------
  
  ErrorMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ErrorMsg& from);
  void MergeFrom(const ErrorMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);
  
  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // @@protoc_insertion_point(class_scope:newcoin.ErrorMsg)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_message();
  inline void clear_has_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* message_;
  ::google::protobuf::int32 errorcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static ErrorMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// Hello

// required int32 version = 1;
inline bool Hello::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hello::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hello::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hello::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Hello::version() const {
  return version_;
}
inline void Hello::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// required bytes nodeID = 2;
inline bool Hello::has_nodeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Hello::set_has_nodeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Hello::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Hello::clear_nodeid() {
  if (nodeid_ != &::google::protobuf::internal::kEmptyString) {
    nodeid_->clear();
  }
  clear_has_nodeid();
}
inline const ::std::string& Hello::nodeid() const {
  return *nodeid_;
}
inline void Hello::set_nodeid(const ::std::string& value) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(value);
}
inline void Hello::set_nodeid(const char* value) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(value);
}
inline void Hello::set_nodeid(const void* value, size_t size) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hello::mutable_nodeid() {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  return nodeid_;
}
inline ::std::string* Hello::release_nodeid() {
  clear_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodeid_;
    nodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes pubKey = 3;
inline bool Hello::has_pubkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Hello::set_has_pubkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Hello::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Hello::clear_pubkey() {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    pubkey_->clear();
  }
  clear_has_pubkey();
}
inline const ::std::string& Hello::pubkey() const {
  return *pubkey_;
}
inline void Hello::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void Hello::set_pubkey(const char* value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void Hello::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hello::mutable_pubkey() {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  return pubkey_;
}
inline ::std::string* Hello::release_pubkey() {
  clear_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pubkey_;
    pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 port = 4;
inline bool Hello::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Hello::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Hello::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Hello::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Hello::port() const {
  return port_;
}
inline void Hello::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional int32 yourIP = 5;
inline bool Hello::has_yourip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Hello::set_has_yourip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Hello::clear_has_yourip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Hello::clear_yourip() {
  yourip_ = 0;
  clear_has_yourip();
}
inline ::google::protobuf::int32 Hello::yourip() const {
  return yourip_;
}
inline void Hello::set_yourip(::google::protobuf::int32 value) {
  set_has_yourip();
  yourip_ = value;
}

// optional int64 netTime = 6;
inline bool Hello::has_nettime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Hello::set_has_nettime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Hello::clear_has_nettime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Hello::clear_nettime() {
  nettime_ = GOOGLE_LONGLONG(0);
  clear_has_nettime();
}
inline ::google::protobuf::int64 Hello::nettime() const {
  return nettime_;
}
inline void Hello::set_nettime(::google::protobuf::int64 value) {
  set_has_nettime();
  nettime_ = value;
}

// -------------------------------------------------------------------

// Transaction

// required bytes from = 1;
inline bool Transaction::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Transaction::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Transaction::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Transaction::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& Transaction::from() const {
  return *from_;
}
inline void Transaction::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void Transaction::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void Transaction::set_from(const void* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Transaction::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* Transaction::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes dest = 2;
inline bool Transaction::has_dest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Transaction::set_has_dest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Transaction::clear_has_dest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Transaction::clear_dest() {
  if (dest_ != &::google::protobuf::internal::kEmptyString) {
    dest_->clear();
  }
  clear_has_dest();
}
inline const ::std::string& Transaction::dest() const {
  return *dest_;
}
inline void Transaction::set_dest(const ::std::string& value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
}
inline void Transaction::set_dest(const char* value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
}
inline void Transaction::set_dest(const void* value, size_t size) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Transaction::mutable_dest() {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  return dest_;
}
inline ::std::string* Transaction::release_dest() {
  clear_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dest_;
    dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 amount = 3;
inline bool Transaction::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Transaction::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Transaction::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Transaction::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 Transaction::amount() const {
  return amount_;
}
inline void Transaction::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// required uint32 sourceLedgerIndex = 4;
inline bool Transaction::has_sourceledgerindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Transaction::set_has_sourceledgerindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Transaction::clear_has_sourceledgerindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Transaction::clear_sourceledgerindex() {
  sourceledgerindex_ = 0u;
  clear_has_sourceledgerindex();
}
inline ::google::protobuf::uint32 Transaction::sourceledgerindex() const {
  return sourceledgerindex_;
}
inline void Transaction::set_sourceledgerindex(::google::protobuf::uint32 value) {
  set_has_sourceledgerindex();
  sourceledgerindex_ = value;
}

// required uint32 seqNum = 5;
inline bool Transaction::has_seqnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Transaction::set_has_seqnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Transaction::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Transaction::clear_seqnum() {
  seqnum_ = 0u;
  clear_has_seqnum();
}
inline ::google::protobuf::uint32 Transaction::seqnum() const {
  return seqnum_;
}
inline void Transaction::set_seqnum(::google::protobuf::uint32 value) {
  set_has_seqnum();
  seqnum_ = value;
}

// required uint32 ident = 6;
inline bool Transaction::has_ident() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Transaction::set_has_ident() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Transaction::clear_has_ident() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Transaction::clear_ident() {
  ident_ = 0u;
  clear_has_ident();
}
inline ::google::protobuf::uint32 Transaction::ident() const {
  return ident_;
}
inline void Transaction::set_ident(::google::protobuf::uint32 value) {
  set_has_ident();
  ident_ = value;
}

// required bytes pubKey = 7;
inline bool Transaction::has_pubkey() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Transaction::set_has_pubkey() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Transaction::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Transaction::clear_pubkey() {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    pubkey_->clear();
  }
  clear_has_pubkey();
}
inline const ::std::string& Transaction::pubkey() const {
  return *pubkey_;
}
inline void Transaction::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void Transaction::set_pubkey(const char* value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void Transaction::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Transaction::mutable_pubkey() {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  return pubkey_;
}
inline ::std::string* Transaction::release_pubkey() {
  clear_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pubkey_;
    pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes sig = 8;
inline bool Transaction::has_sig() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Transaction::set_has_sig() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Transaction::clear_has_sig() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Transaction::clear_sig() {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    sig_->clear();
  }
  clear_has_sig();
}
inline const ::std::string& Transaction::sig() const {
  return *sig_;
}
inline void Transaction::set_sig(const ::std::string& value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void Transaction::set_sig(const char* value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void Transaction::set_sig(const void* value, size_t size) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Transaction::mutable_sig() {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  return sig_;
}
inline ::std::string* Transaction::release_sig() {
  clear_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sig_;
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .newcoin.TransactionStatus status = 9;
inline bool Transaction::has_status() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Transaction::set_has_status() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Transaction::clear_has_status() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Transaction::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline newcoin::TransactionStatus Transaction::status() const {
  return static_cast< newcoin::TransactionStatus >(status_);
}
inline void Transaction::set_status(newcoin::TransactionStatus value) {
  GOOGLE_DCHECK(newcoin::TransactionStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional uint32 ledgerIndex = 10;
inline bool Transaction::has_ledgerindex() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Transaction::set_has_ledgerindex() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Transaction::clear_has_ledgerindex() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Transaction::clear_ledgerindex() {
  ledgerindex_ = 0u;
  clear_has_ledgerindex();
}
inline ::google::protobuf::uint32 Transaction::ledgerindex() const {
  return ledgerindex_;
}
inline void Transaction::set_ledgerindex(::google::protobuf::uint32 value) {
  set_has_ledgerindex();
  ledgerindex_ = value;
}

// -------------------------------------------------------------------

// Validation

// required uint32 ledgerIndex = 1;
inline bool Validation::has_ledgerindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Validation::set_has_ledgerindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Validation::clear_has_ledgerindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Validation::clear_ledgerindex() {
  ledgerindex_ = 0u;
  clear_has_ledgerindex();
}
inline ::google::protobuf::uint32 Validation::ledgerindex() const {
  return ledgerindex_;
}
inline void Validation::set_ledgerindex(::google::protobuf::uint32 value) {
  set_has_ledgerindex();
  ledgerindex_ = value;
}

// required bytes hash = 2;
inline bool Validation::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Validation::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Validation::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Validation::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& Validation::hash() const {
  return *hash_;
}
inline void Validation::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void Validation::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void Validation::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Validation::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* Validation::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes hanko = 3;
inline bool Validation::has_hanko() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Validation::set_has_hanko() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Validation::clear_has_hanko() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Validation::clear_hanko() {
  if (hanko_ != &::google::protobuf::internal::kEmptyString) {
    hanko_->clear();
  }
  clear_has_hanko();
}
inline const ::std::string& Validation::hanko() const {
  return *hanko_;
}
inline void Validation::set_hanko(const ::std::string& value) {
  set_has_hanko();
  if (hanko_ == &::google::protobuf::internal::kEmptyString) {
    hanko_ = new ::std::string;
  }
  hanko_->assign(value);
}
inline void Validation::set_hanko(const char* value) {
  set_has_hanko();
  if (hanko_ == &::google::protobuf::internal::kEmptyString) {
    hanko_ = new ::std::string;
  }
  hanko_->assign(value);
}
inline void Validation::set_hanko(const void* value, size_t size) {
  set_has_hanko();
  if (hanko_ == &::google::protobuf::internal::kEmptyString) {
    hanko_ = new ::std::string;
  }
  hanko_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Validation::mutable_hanko() {
  set_has_hanko();
  if (hanko_ == &::google::protobuf::internal::kEmptyString) {
    hanko_ = new ::std::string;
  }
  return hanko_;
}
inline ::std::string* Validation::release_hanko() {
  clear_has_hanko();
  if (hanko_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hanko_;
    hanko_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 seqNum = 4;
inline bool Validation::has_seqnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Validation::set_has_seqnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Validation::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Validation::clear_seqnum() {
  seqnum_ = 0;
  clear_has_seqnum();
}
inline ::google::protobuf::int32 Validation::seqnum() const {
  return seqnum_;
}
inline void Validation::set_seqnum(::google::protobuf::int32 value) {
  set_has_seqnum();
  seqnum_ = value;
}

// required bytes sig = 5;
inline bool Validation::has_sig() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Validation::set_has_sig() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Validation::clear_has_sig() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Validation::clear_sig() {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    sig_->clear();
  }
  clear_has_sig();
}
inline const ::std::string& Validation::sig() const {
  return *sig_;
}
inline void Validation::set_sig(const ::std::string& value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void Validation::set_sig(const char* value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void Validation::set_sig(const void* value, size_t size) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Validation::mutable_sig() {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  return sig_;
}
inline ::std::string* Validation::release_sig() {
  clear_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sig_;
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Account

// required bytes address = 1;
inline bool Account::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Account::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Account::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Account::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& Account::address() const {
  return *address_;
}
inline void Account::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Account::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Account::set_address(const void* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Account::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* Account::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 amount = 2;
inline bool Account::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Account::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Account::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Account::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 Account::amount() const {
  return amount_;
}
inline void Account::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// required uint32 seqNum = 3;
inline bool Account::has_seqnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Account::set_has_seqnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Account::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Account::clear_seqnum() {
  seqnum_ = 0u;
  clear_has_seqnum();
}
inline ::google::protobuf::uint32 Account::seqnum() const {
  return seqnum_;
}
inline void Account::set_seqnum(::google::protobuf::uint32 value) {
  set_has_seqnum();
  seqnum_ = value;
}

// -------------------------------------------------------------------

// FullLedger

// required uint32 index = 1;
inline bool FullLedger::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FullLedger::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FullLedger::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FullLedger::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 FullLedger::index() const {
  return index_;
}
inline void FullLedger::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required bytes hash = 2;
inline bool FullLedger::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FullLedger::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FullLedger::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FullLedger::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& FullLedger::hash() const {
  return *hash_;
}
inline void FullLedger::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void FullLedger::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void FullLedger::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FullLedger::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* FullLedger::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes parentHash = 3;
inline bool FullLedger::has_parenthash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FullLedger::set_has_parenthash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FullLedger::clear_has_parenthash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FullLedger::clear_parenthash() {
  if (parenthash_ != &::google::protobuf::internal::kEmptyString) {
    parenthash_->clear();
  }
  clear_has_parenthash();
}
inline const ::std::string& FullLedger::parenthash() const {
  return *parenthash_;
}
inline void FullLedger::set_parenthash(const ::std::string& value) {
  set_has_parenthash();
  if (parenthash_ == &::google::protobuf::internal::kEmptyString) {
    parenthash_ = new ::std::string;
  }
  parenthash_->assign(value);
}
inline void FullLedger::set_parenthash(const char* value) {
  set_has_parenthash();
  if (parenthash_ == &::google::protobuf::internal::kEmptyString) {
    parenthash_ = new ::std::string;
  }
  parenthash_->assign(value);
}
inline void FullLedger::set_parenthash(const void* value, size_t size) {
  set_has_parenthash();
  if (parenthash_ == &::google::protobuf::internal::kEmptyString) {
    parenthash_ = new ::std::string;
  }
  parenthash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FullLedger::mutable_parenthash() {
  set_has_parenthash();
  if (parenthash_ == &::google::protobuf::internal::kEmptyString) {
    parenthash_ = new ::std::string;
  }
  return parenthash_;
}
inline ::std::string* FullLedger::release_parenthash() {
  clear_has_parenthash();
  if (parenthash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parenthash_;
    parenthash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 feeHeld = 4;
inline bool FullLedger::has_feeheld() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FullLedger::set_has_feeheld() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FullLedger::clear_has_feeheld() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FullLedger::clear_feeheld() {
  feeheld_ = GOOGLE_ULONGLONG(0);
  clear_has_feeheld();
}
inline ::google::protobuf::uint64 FullLedger::feeheld() const {
  return feeheld_;
}
inline void FullLedger::set_feeheld(::google::protobuf::uint64 value) {
  set_has_feeheld();
  feeheld_ = value;
}

// repeated .newcoin.Account accounts = 5;
inline int FullLedger::accounts_size() const {
  return accounts_.size();
}
inline void FullLedger::clear_accounts() {
  accounts_.Clear();
}
inline const ::newcoin::Account& FullLedger::accounts(int index) const {
  return accounts_.Get(index);
}
inline ::newcoin::Account* FullLedger::mutable_accounts(int index) {
  return accounts_.Mutable(index);
}
inline ::newcoin::Account* FullLedger::add_accounts() {
  return accounts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::newcoin::Account >&
FullLedger::accounts() const {
  return accounts_;
}
inline ::google::protobuf::RepeatedPtrField< ::newcoin::Account >*
FullLedger::mutable_accounts() {
  return &accounts_;
}

// repeated .newcoin.Transaction transactions = 6;
inline int FullLedger::transactions_size() const {
  return transactions_.size();
}
inline void FullLedger::clear_transactions() {
  transactions_.Clear();
}
inline const ::newcoin::Transaction& FullLedger::transactions(int index) const {
  return transactions_.Get(index);
}
inline ::newcoin::Transaction* FullLedger::mutable_transactions(int index) {
  return transactions_.Mutable(index);
}
inline ::newcoin::Transaction* FullLedger::add_transactions() {
  return transactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::newcoin::Transaction >&
FullLedger::transactions() const {
  return transactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::newcoin::Transaction >*
FullLedger::mutable_transactions() {
  return &transactions_;
}

// -------------------------------------------------------------------

// GetFullLedger

// required bytes hash = 1;
inline bool GetFullLedger::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFullLedger::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFullLedger::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFullLedger::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& GetFullLedger::hash() const {
  return *hash_;
}
inline void GetFullLedger::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void GetFullLedger::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void GetFullLedger::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFullLedger::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* GetFullLedger::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetValidations

// required uint32 ledgerIndex = 1;
inline bool GetValidations::has_ledgerindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetValidations::set_has_ledgerindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetValidations::clear_has_ledgerindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetValidations::clear_ledgerindex() {
  ledgerindex_ = 0u;
  clear_has_ledgerindex();
}
inline ::google::protobuf::uint32 GetValidations::ledgerindex() const {
  return ledgerindex_;
}
inline void GetValidations::set_ledgerindex(::google::protobuf::uint32 value) {
  set_has_ledgerindex();
  ledgerindex_ = value;
}

// -------------------------------------------------------------------

// Contact_NodeInfo

// required .newcoin.Contact.NodeInfo.infoType NItype = 1;
inline bool Contact_NodeInfo::has_nitype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Contact_NodeInfo::set_has_nitype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Contact_NodeInfo::clear_has_nitype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Contact_NodeInfo::clear_nitype() {
  nitype_ = 0;
  clear_has_nitype();
}
inline ::newcoin::Contact_NodeInfo_infoType Contact_NodeInfo::nitype() const {
  return static_cast< ::newcoin::Contact_NodeInfo_infoType >(nitype_);
}
inline void Contact_NodeInfo::set_nitype(::newcoin::Contact_NodeInfo_infoType value) {
  GOOGLE_DCHECK(::newcoin::Contact_NodeInfo_infoType_IsValid(value));
  set_has_nitype();
  nitype_ = value;
}

// required string NIvalue = 2;
inline bool Contact_NodeInfo::has_nivalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Contact_NodeInfo::set_has_nivalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Contact_NodeInfo::clear_has_nivalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Contact_NodeInfo::clear_nivalue() {
  if (nivalue_ != &::google::protobuf::internal::kEmptyString) {
    nivalue_->clear();
  }
  clear_has_nivalue();
}
inline const ::std::string& Contact_NodeInfo::nivalue() const {
  return *nivalue_;
}
inline void Contact_NodeInfo::set_nivalue(const ::std::string& value) {
  set_has_nivalue();
  if (nivalue_ == &::google::protobuf::internal::kEmptyString) {
    nivalue_ = new ::std::string;
  }
  nivalue_->assign(value);
}
inline void Contact_NodeInfo::set_nivalue(const char* value) {
  set_has_nivalue();
  if (nivalue_ == &::google::protobuf::internal::kEmptyString) {
    nivalue_ = new ::std::string;
  }
  nivalue_->assign(value);
}
inline void Contact_NodeInfo::set_nivalue(const char* value, size_t size) {
  set_has_nivalue();
  if (nivalue_ == &::google::protobuf::internal::kEmptyString) {
    nivalue_ = new ::std::string;
  }
  nivalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Contact_NodeInfo::mutable_nivalue() {
  set_has_nivalue();
  if (nivalue_ == &::google::protobuf::internal::kEmptyString) {
    nivalue_ = new ::std::string;
  }
  return nivalue_;
}
inline ::std::string* Contact_NodeInfo::release_nivalue() {
  clear_has_nivalue();
  if (nivalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nivalue_;
    nivalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Contact_ContactInfo

// required string nodeID = 1;
inline bool Contact_ContactInfo::has_nodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Contact_ContactInfo::set_has_nodeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Contact_ContactInfo::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Contact_ContactInfo::clear_nodeid() {
  if (nodeid_ != &::google::protobuf::internal::kEmptyString) {
    nodeid_->clear();
  }
  clear_has_nodeid();
}
inline const ::std::string& Contact_ContactInfo::nodeid() const {
  return *nodeid_;
}
inline void Contact_ContactInfo::set_nodeid(const ::std::string& value) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(value);
}
inline void Contact_ContactInfo::set_nodeid(const char* value) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(value);
}
inline void Contact_ContactInfo::set_nodeid(const char* value, size_t size) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Contact_ContactInfo::mutable_nodeid() {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  return nodeid_;
}
inline ::std::string* Contact_ContactInfo::release_nodeid() {
  clear_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodeid_;
    nodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes pubKey = 2;
inline bool Contact_ContactInfo::has_pubkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Contact_ContactInfo::set_has_pubkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Contact_ContactInfo::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Contact_ContactInfo::clear_pubkey() {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    pubkey_->clear();
  }
  clear_has_pubkey();
}
inline const ::std::string& Contact_ContactInfo::pubkey() const {
  return *pubkey_;
}
inline void Contact_ContactInfo::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void Contact_ContactInfo::set_pubkey(const char* value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void Contact_ContactInfo::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Contact_ContactInfo::mutable_pubkey() {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  return pubkey_;
}
inline ::std::string* Contact_ContactInfo::release_pubkey() {
  clear_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pubkey_;
    pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string nodeIP = 3;
inline bool Contact_ContactInfo::has_nodeip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Contact_ContactInfo::set_has_nodeip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Contact_ContactInfo::clear_has_nodeip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Contact_ContactInfo::clear_nodeip() {
  if (nodeip_ != &::google::protobuf::internal::kEmptyString) {
    nodeip_->clear();
  }
  clear_has_nodeip();
}
inline const ::std::string& Contact_ContactInfo::nodeip() const {
  return *nodeip_;
}
inline void Contact_ContactInfo::set_nodeip(const ::std::string& value) {
  set_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::kEmptyString) {
    nodeip_ = new ::std::string;
  }
  nodeip_->assign(value);
}
inline void Contact_ContactInfo::set_nodeip(const char* value) {
  set_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::kEmptyString) {
    nodeip_ = new ::std::string;
  }
  nodeip_->assign(value);
}
inline void Contact_ContactInfo::set_nodeip(const char* value, size_t size) {
  set_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::kEmptyString) {
    nodeip_ = new ::std::string;
  }
  nodeip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Contact_ContactInfo::mutable_nodeip() {
  set_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::kEmptyString) {
    nodeip_ = new ::std::string;
  }
  return nodeip_;
}
inline ::std::string* Contact_ContactInfo::release_nodeip() {
  clear_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodeip_;
    nodeip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string additionalIPs = 4;
inline int Contact_ContactInfo::additionalips_size() const {
  return additionalips_.size();
}
inline void Contact_ContactInfo::clear_additionalips() {
  additionalips_.Clear();
}
inline const ::std::string& Contact_ContactInfo::additionalips(int index) const {
  return additionalips_.Get(index);
}
inline ::std::string* Contact_ContactInfo::mutable_additionalips(int index) {
  return additionalips_.Mutable(index);
}
inline void Contact_ContactInfo::set_additionalips(int index, const ::std::string& value) {
  additionalips_.Mutable(index)->assign(value);
}
inline void Contact_ContactInfo::set_additionalips(int index, const char* value) {
  additionalips_.Mutable(index)->assign(value);
}
inline void Contact_ContactInfo::set_additionalips(int index, const char* value, size_t size) {
  additionalips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Contact_ContactInfo::add_additionalips() {
  return additionalips_.Add();
}
inline void Contact_ContactInfo::add_additionalips(const ::std::string& value) {
  additionalips_.Add()->assign(value);
}
inline void Contact_ContactInfo::add_additionalips(const char* value) {
  additionalips_.Add()->assign(value);
}
inline void Contact_ContactInfo::add_additionalips(const char* value, size_t size) {
  additionalips_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Contact_ContactInfo::additionalips() const {
  return additionalips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Contact_ContactInfo::mutable_additionalips() {
  return &additionalips_;
}

// required int32 port = 5;
inline bool Contact_ContactInfo::has_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Contact_ContactInfo::set_has_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Contact_ContactInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Contact_ContactInfo::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Contact_ContactInfo::port() const {
  return port_;
}
inline void Contact_ContactInfo::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// required int32 protoVersion = 6;
inline bool Contact_ContactInfo::has_protoversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Contact_ContactInfo::set_has_protoversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Contact_ContactInfo::clear_has_protoversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Contact_ContactInfo::clear_protoversion() {
  protoversion_ = 0;
  clear_has_protoversion();
}
inline ::google::protobuf::int32 Contact_ContactInfo::protoversion() const {
  return protoversion_;
}
inline void Contact_ContactInfo::set_protoversion(::google::protobuf::int32 value) {
  set_has_protoversion();
  protoversion_ = value;
}

// required int32 nodeFlags = 7;
inline bool Contact_ContactInfo::has_nodeflags() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Contact_ContactInfo::set_has_nodeflags() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Contact_ContactInfo::clear_has_nodeflags() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Contact_ContactInfo::clear_nodeflags() {
  nodeflags_ = 0;
  clear_has_nodeflags();
}
inline ::google::protobuf::int32 Contact_ContactInfo::nodeflags() const {
  return nodeflags_;
}
inline void Contact_ContactInfo::set_nodeflags(::google::protobuf::int32 value) {
  set_has_nodeflags();
  nodeflags_ = value;
}

// repeated .newcoin.Contact.NodeInfo nodeInfo = 8;
inline int Contact_ContactInfo::nodeinfo_size() const {
  return nodeinfo_.size();
}
inline void Contact_ContactInfo::clear_nodeinfo() {
  nodeinfo_.Clear();
}
inline const ::newcoin::Contact_NodeInfo& Contact_ContactInfo::nodeinfo(int index) const {
  return nodeinfo_.Get(index);
}
inline ::newcoin::Contact_NodeInfo* Contact_ContactInfo::mutable_nodeinfo(int index) {
  return nodeinfo_.Mutable(index);
}
inline ::newcoin::Contact_NodeInfo* Contact_ContactInfo::add_nodeinfo() {
  return nodeinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::newcoin::Contact_NodeInfo >&
Contact_ContactInfo::nodeinfo() const {
  return nodeinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::newcoin::Contact_NodeInfo >*
Contact_ContactInfo::mutable_nodeinfo() {
  return &nodeinfo_;
}

// optional uint64 timestamp = 9;
inline bool Contact_ContactInfo::has_timestamp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Contact_ContactInfo::set_has_timestamp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Contact_ContactInfo::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Contact_ContactInfo::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 Contact_ContactInfo::timestamp() const {
  return timestamp_;
}
inline void Contact_ContactInfo::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// Contact

// required .newcoin.Contact.ContactInfo nodeInfo = 1;
inline bool Contact::has_nodeinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Contact::set_has_nodeinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Contact::clear_has_nodeinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Contact::clear_nodeinfo() {
  if (nodeinfo_ != NULL) nodeinfo_->::newcoin::Contact_ContactInfo::Clear();
  clear_has_nodeinfo();
}
inline const ::newcoin::Contact_ContactInfo& Contact::nodeinfo() const {
  return nodeinfo_ != NULL ? *nodeinfo_ : *default_instance_->nodeinfo_;
}
inline ::newcoin::Contact_ContactInfo* Contact::mutable_nodeinfo() {
  set_has_nodeinfo();
  if (nodeinfo_ == NULL) nodeinfo_ = new ::newcoin::Contact_ContactInfo;
  return nodeinfo_;
}
inline ::newcoin::Contact_ContactInfo* Contact::release_nodeinfo() {
  clear_has_nodeinfo();
  ::newcoin::Contact_ContactInfo* temp = nodeinfo_;
  nodeinfo_ = NULL;
  return temp;
}

// required bytes signature = 2;
inline bool Contact::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Contact::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Contact::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Contact::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& Contact::signature() const {
  return *signature_;
}
inline void Contact::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void Contact::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void Contact::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Contact::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* Contact::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 distance = 3;
inline bool Contact::has_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Contact::set_has_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Contact::clear_has_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Contact::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline ::google::protobuf::int32 Contact::distance() const {
  return distance_;
}
inline void Contact::set_distance(::google::protobuf::int32 value) {
  set_has_distance();
  distance_ = value;
}

// -------------------------------------------------------------------

// GetContacts

// repeated bytes nodeIDs = 1;
inline int GetContacts::nodeids_size() const {
  return nodeids_.size();
}
inline void GetContacts::clear_nodeids() {
  nodeids_.Clear();
}
inline const ::std::string& GetContacts::nodeids(int index) const {
  return nodeids_.Get(index);
}
inline ::std::string* GetContacts::mutable_nodeids(int index) {
  return nodeids_.Mutable(index);
}
inline void GetContacts::set_nodeids(int index, const ::std::string& value) {
  nodeids_.Mutable(index)->assign(value);
}
inline void GetContacts::set_nodeids(int index, const char* value) {
  nodeids_.Mutable(index)->assign(value);
}
inline void GetContacts::set_nodeids(int index, const void* value, size_t size) {
  nodeids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetContacts::add_nodeids() {
  return nodeids_.Add();
}
inline void GetContacts::add_nodeids(const ::std::string& value) {
  nodeids_.Add()->assign(value);
}
inline void GetContacts::add_nodeids(const char* value) {
  nodeids_.Add()->assign(value);
}
inline void GetContacts::add_nodeids(const void* value, size_t size) {
  nodeids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetContacts::nodeids() const {
  return nodeids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetContacts::mutable_nodeids() {
  return &nodeids_;
}

// optional int32 nodeCount = 2;
inline bool GetContacts::has_nodecount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetContacts::set_has_nodecount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetContacts::clear_has_nodecount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetContacts::clear_nodecount() {
  nodecount_ = 0;
  clear_has_nodecount();
}
inline ::google::protobuf::int32 GetContacts::nodecount() const {
  return nodecount_;
}
inline void GetContacts::set_nodecount(::google::protobuf::int32 value) {
  set_has_nodecount();
  nodecount_ = value;
}

// -------------------------------------------------------------------

// ProposeLedger

// required uint32 ledgerIndex = 1;
inline bool ProposeLedger::has_ledgerindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProposeLedger::set_has_ledgerindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProposeLedger::clear_has_ledgerindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProposeLedger::clear_ledgerindex() {
  ledgerindex_ = 0u;
  clear_has_ledgerindex();
}
inline ::google::protobuf::uint32 ProposeLedger::ledgerindex() const {
  return ledgerindex_;
}
inline void ProposeLedger::set_ledgerindex(::google::protobuf::uint32 value) {
  set_has_ledgerindex();
  ledgerindex_ = value;
}

// required bytes hash = 2;
inline bool ProposeLedger::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProposeLedger::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProposeLedger::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProposeLedger::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& ProposeLedger::hash() const {
  return *hash_;
}
inline void ProposeLedger::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void ProposeLedger::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void ProposeLedger::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProposeLedger::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* ProposeLedger::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint64 numTransactions = 3;
inline bool ProposeLedger::has_numtransactions() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProposeLedger::set_has_numtransactions() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProposeLedger::clear_has_numtransactions() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProposeLedger::clear_numtransactions() {
  numtransactions_ = GOOGLE_ULONGLONG(0);
  clear_has_numtransactions();
}
inline ::google::protobuf::uint64 ProposeLedger::numtransactions() const {
  return numtransactions_;
}
inline void ProposeLedger::set_numtransactions(::google::protobuf::uint64 value) {
  set_has_numtransactions();
  numtransactions_ = value;
}

// -------------------------------------------------------------------

// Ping

// required .newcoin.Ping.pingType type = 1;
inline bool Ping::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ping::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ping::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::newcoin::Ping_pingType Ping::type() const {
  return static_cast< ::newcoin::Ping_pingType >(type_);
}
inline void Ping::set_type(::newcoin::Ping_pingType value) {
  GOOGLE_DCHECK(::newcoin::Ping_pingType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 pingVal = 2;
inline bool Ping::has_pingval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ping::set_has_pingval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ping::clear_has_pingval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ping::clear_pingval() {
  pingval_ = 0;
  clear_has_pingval();
}
inline ::google::protobuf::int32 Ping::pingval() const {
  return pingval_;
}
inline void Ping::set_pingval(::google::protobuf::int32 value) {
  set_has_pingval();
  pingval_ = value;
}

// optional uint64 pingTime = 3;
inline bool Ping::has_pingtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ping::set_has_pingtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ping::clear_has_pingtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ping::clear_pingtime() {
  pingtime_ = GOOGLE_ULONGLONG(0);
  clear_has_pingtime();
}
inline ::google::protobuf::uint64 Ping::pingtime() const {
  return pingtime_;
}
inline void Ping::set_pingtime(::google::protobuf::uint64 value) {
  set_has_pingtime();
  pingtime_ = value;
}

// optional uint64 netTime = 4;
inline bool Ping::has_nettime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ping::set_has_nettime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ping::clear_has_nettime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ping::clear_nettime() {
  nettime_ = GOOGLE_ULONGLONG(0);
  clear_has_nettime();
}
inline ::google::protobuf::uint64 Ping::nettime() const {
  return nettime_;
}
inline void Ping::set_nettime(::google::protobuf::uint64 value) {
  set_has_nettime();
  nettime_ = value;
}

// -------------------------------------------------------------------

// ErrorMsg

// optional int32 errorCode = 1;
inline bool ErrorMsg::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorMsg::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorMsg::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorMsg::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 ErrorMsg::errorcode() const {
  return errorcode_;
}
inline void ErrorMsg::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional string message = 2;
inline bool ErrorMsg::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ErrorMsg::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ErrorMsg::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ErrorMsg::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ErrorMsg::message() const {
  return *message_;
}
inline void ErrorMsg::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ErrorMsg::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ErrorMsg::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ErrorMsg::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ErrorMsg::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace newcoin

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::newcoin::Contact_NodeInfo_infoType>() {
  return ::newcoin::Contact_NodeInfo_infoType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::newcoin::Ping_pingType>() {
  return ::newcoin::Ping_pingType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< newcoin::Type>() {
  return newcoin::Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< newcoin::TransactionStatus>() {
  return newcoin::TransactionStatus_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_newcoin_2eproto__INCLUDED

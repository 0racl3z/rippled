// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: newcoin.proto

#ifndef PROTOBUF_newcoin_2eproto__INCLUDED
#define PROTOBUF_newcoin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace newcoin {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_newcoin_2eproto();
void protobuf_AssignDesc_newcoin_2eproto();
void protobuf_ShutdownFile_newcoin_2eproto();

class Hello;
class Transaction;
class Validation;
class Account;
class FullLedger;
class GetFullLedger;
class GetValidations;
class Contact;
class ProposeLedger;
class ErrorMsg;

enum Type {
  HELLO = 1,
  TRANSACTION = 2,
  FULL_LEDGER = 3,
  VALIDATION = 4,
  PROPOSE_LEDGER = 5,
  GET_FULL_LEDGER = 6,
  GET_VALIDATIONS = 7,
  GET_CONTACTS = 8,
  CONTACT = 9,
  ERROR_MSG = 10
};
bool Type_IsValid(int value);
const Type Type_MIN = HELLO;
const Type Type_MAX = ERROR_MSG;
const int Type_ARRAYSIZE = Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Type_descriptor();
inline const ::std::string& Type_Name(Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Type_descriptor(), value);
}
inline bool Type_Parse(
    const ::std::string& name, Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
// ===================================================================

class Hello : public ::google::protobuf::Message {
 public:
  Hello();
  virtual ~Hello();
  
  Hello(const Hello& from);
  
  inline Hello& operator=(const Hello& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Hello& default_instance();
  
  void Swap(Hello* other);
  
  // implements Message ----------------------------------------------
  
  Hello* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hello& from);
  void MergeFrom(const Hello& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // required bytes nodeID = 2;
  inline bool has_nodeid() const;
  inline void clear_nodeid();
  static const int kNodeIDFieldNumber = 2;
  inline const ::std::string& nodeid() const;
  inline void set_nodeid(const ::std::string& value);
  inline void set_nodeid(const char* value);
  inline void set_nodeid(const void* value, size_t size);
  inline ::std::string* mutable_nodeid();
  inline ::std::string* release_nodeid();
  
  // required int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:newcoin.Hello)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_nodeid();
  inline void clear_has_nodeid();
  inline void set_has_port();
  inline void clear_has_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nodeid_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static Hello* default_instance_;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message {
 public:
  Transaction();
  virtual ~Transaction();
  
  Transaction(const Transaction& from);
  
  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();
  
  void Swap(Transaction* other);
  
  // implements Message ----------------------------------------------
  
  Transaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const void* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  
  // required bytes dest = 2;
  inline bool has_dest() const;
  inline void clear_dest();
  static const int kDestFieldNumber = 2;
  inline const ::std::string& dest() const;
  inline void set_dest(const ::std::string& value);
  inline void set_dest(const char* value);
  inline void set_dest(const void* value, size_t size);
  inline ::std::string* mutable_dest();
  inline ::std::string* release_dest();
  
  // required uint64 amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);
  
  // required uint32 ledgerIndex = 4;
  inline bool has_ledgerindex() const;
  inline void clear_ledgerindex();
  static const int kLedgerIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 ledgerindex() const;
  inline void set_ledgerindex(::google::protobuf::uint32 value);
  
  // required int32 seqNum = 5;
  inline bool has_seqnum() const;
  inline void clear_seqnum();
  static const int kSeqNumFieldNumber = 5;
  inline ::google::protobuf::int32 seqnum() const;
  inline void set_seqnum(::google::protobuf::int32 value);
  
  // required bytes pubKey = 6;
  inline bool has_pubkey() const;
  inline void clear_pubkey();
  static const int kPubKeyFieldNumber = 6;
  inline const ::std::string& pubkey() const;
  inline void set_pubkey(const ::std::string& value);
  inline void set_pubkey(const char* value);
  inline void set_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_pubkey();
  inline ::std::string* release_pubkey();
  
  // required bytes sig = 7;
  inline bool has_sig() const;
  inline void clear_sig();
  static const int kSigFieldNumber = 7;
  inline const ::std::string& sig() const;
  inline void set_sig(const ::std::string& value);
  inline void set_sig(const char* value);
  inline void set_sig(const void* value, size_t size);
  inline ::std::string* mutable_sig();
  inline ::std::string* release_sig();
  
  // @@protoc_insertion_point(class_scope:newcoin.Transaction)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_dest();
  inline void clear_has_dest();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_ledgerindex();
  inline void clear_has_ledgerindex();
  inline void set_has_seqnum();
  inline void clear_has_seqnum();
  inline void set_has_pubkey();
  inline void clear_has_pubkey();
  inline void set_has_sig();
  inline void clear_has_sig();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* from_;
  ::std::string* dest_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint32 ledgerindex_;
  ::google::protobuf::int32 seqnum_;
  ::std::string* pubkey_;
  ::std::string* sig_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static Transaction* default_instance_;
};
// -------------------------------------------------------------------

class Validation : public ::google::protobuf::Message {
 public:
  Validation();
  virtual ~Validation();
  
  Validation(const Validation& from);
  
  inline Validation& operator=(const Validation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Validation& default_instance();
  
  void Swap(Validation* other);
  
  // implements Message ----------------------------------------------
  
  Validation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Validation& from);
  void MergeFrom(const Validation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 ledgerIndex = 1;
  inline bool has_ledgerindex() const;
  inline void clear_ledgerindex();
  static const int kLedgerIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 ledgerindex() const;
  inline void set_ledgerindex(::google::protobuf::uint32 value);
  
  // required bytes hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  
  // required bytes hanko = 3;
  inline bool has_hanko() const;
  inline void clear_hanko();
  static const int kHankoFieldNumber = 3;
  inline const ::std::string& hanko() const;
  inline void set_hanko(const ::std::string& value);
  inline void set_hanko(const char* value);
  inline void set_hanko(const void* value, size_t size);
  inline ::std::string* mutable_hanko();
  inline ::std::string* release_hanko();
  
  // required int32 seqNum = 4;
  inline bool has_seqnum() const;
  inline void clear_seqnum();
  static const int kSeqNumFieldNumber = 4;
  inline ::google::protobuf::int32 seqnum() const;
  inline void set_seqnum(::google::protobuf::int32 value);
  
  // required bytes sig = 5;
  inline bool has_sig() const;
  inline void clear_sig();
  static const int kSigFieldNumber = 5;
  inline const ::std::string& sig() const;
  inline void set_sig(const ::std::string& value);
  inline void set_sig(const char* value);
  inline void set_sig(const void* value, size_t size);
  inline ::std::string* mutable_sig();
  inline ::std::string* release_sig();
  
  // @@protoc_insertion_point(class_scope:newcoin.Validation)
 private:
  inline void set_has_ledgerindex();
  inline void clear_has_ledgerindex();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_hanko();
  inline void clear_has_hanko();
  inline void set_has_seqnum();
  inline void clear_has_seqnum();
  inline void set_has_sig();
  inline void clear_has_sig();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* hash_;
  ::google::protobuf::uint32 ledgerindex_;
  ::google::protobuf::int32 seqnum_;
  ::std::string* hanko_;
  ::std::string* sig_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static Validation* default_instance_;
};
// -------------------------------------------------------------------

class Account : public ::google::protobuf::Message {
 public:
  Account();
  virtual ~Account();
  
  Account(const Account& from);
  
  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();
  
  void Swap(Account* other);
  
  // implements Message ----------------------------------------------
  
  Account* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const void* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  
  // required uint64 amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);
  
  // required uint32 seqNum = 3;
  inline bool has_seqnum() const;
  inline void clear_seqnum();
  static const int kSeqNumFieldNumber = 3;
  inline ::google::protobuf::uint32 seqnum() const;
  inline void set_seqnum(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:newcoin.Account)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_seqnum();
  inline void clear_has_seqnum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* address_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint32 seqnum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static Account* default_instance_;
};
// -------------------------------------------------------------------

class FullLedger : public ::google::protobuf::Message {
 public:
  FullLedger();
  virtual ~FullLedger();
  
  FullLedger(const FullLedger& from);
  
  inline FullLedger& operator=(const FullLedger& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FullLedger& default_instance();
  
  void Swap(FullLedger* other);
  
  // implements Message ----------------------------------------------
  
  FullLedger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FullLedger& from);
  void MergeFrom(const FullLedger& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);
  
  // required bytes hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  
  // required bytes parentHash = 3;
  inline bool has_parenthash() const;
  inline void clear_parenthash();
  static const int kParentHashFieldNumber = 3;
  inline const ::std::string& parenthash() const;
  inline void set_parenthash(const ::std::string& value);
  inline void set_parenthash(const char* value);
  inline void set_parenthash(const void* value, size_t size);
  inline ::std::string* mutable_parenthash();
  inline ::std::string* release_parenthash();
  
  // required uint64 feeHeld = 4;
  inline bool has_feeheld() const;
  inline void clear_feeheld();
  static const int kFeeHeldFieldNumber = 4;
  inline ::google::protobuf::uint64 feeheld() const;
  inline void set_feeheld(::google::protobuf::uint64 value);
  
  // repeated .newcoin.Account accounts = 5;
  inline int accounts_size() const;
  inline void clear_accounts();
  static const int kAccountsFieldNumber = 5;
  inline const ::newcoin::Account& accounts(int index) const;
  inline ::newcoin::Account* mutable_accounts(int index);
  inline ::newcoin::Account* add_accounts();
  inline const ::google::protobuf::RepeatedPtrField< ::newcoin::Account >&
      accounts() const;
  inline ::google::protobuf::RepeatedPtrField< ::newcoin::Account >*
      mutable_accounts();
  
  // repeated .newcoin.Transaction transactions = 6;
  inline int transactions_size() const;
  inline void clear_transactions();
  static const int kTransactionsFieldNumber = 6;
  inline const ::newcoin::Transaction& transactions(int index) const;
  inline ::newcoin::Transaction* mutable_transactions(int index);
  inline ::newcoin::Transaction* add_transactions();
  inline const ::google::protobuf::RepeatedPtrField< ::newcoin::Transaction >&
      transactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::newcoin::Transaction >*
      mutable_transactions();
  
  // @@protoc_insertion_point(class_scope:newcoin.FullLedger)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_parenthash();
  inline void clear_has_parenthash();
  inline void set_has_feeheld();
  inline void clear_has_feeheld();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* hash_;
  ::std::string* parenthash_;
  ::google::protobuf::uint64 feeheld_;
  ::google::protobuf::RepeatedPtrField< ::newcoin::Account > accounts_;
  ::google::protobuf::RepeatedPtrField< ::newcoin::Transaction > transactions_;
  ::google::protobuf::uint32 index_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static FullLedger* default_instance_;
};
// -------------------------------------------------------------------

class GetFullLedger : public ::google::protobuf::Message {
 public:
  GetFullLedger();
  virtual ~GetFullLedger();
  
  GetFullLedger(const GetFullLedger& from);
  
  inline GetFullLedger& operator=(const GetFullLedger& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFullLedger& default_instance();
  
  void Swap(GetFullLedger* other);
  
  // implements Message ----------------------------------------------
  
  GetFullLedger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFullLedger& from);
  void MergeFrom(const GetFullLedger& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes hash = 1;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 1;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  
  // @@protoc_insertion_point(class_scope:newcoin.GetFullLedger)
 private:
  inline void set_has_hash();
  inline void clear_has_hash();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* hash_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static GetFullLedger* default_instance_;
};
// -------------------------------------------------------------------

class GetValidations : public ::google::protobuf::Message {
 public:
  GetValidations();
  virtual ~GetValidations();
  
  GetValidations(const GetValidations& from);
  
  inline GetValidations& operator=(const GetValidations& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetValidations& default_instance();
  
  void Swap(GetValidations* other);
  
  // implements Message ----------------------------------------------
  
  GetValidations* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetValidations& from);
  void MergeFrom(const GetValidations& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 ledgerIndex = 1;
  inline bool has_ledgerindex() const;
  inline void clear_ledgerindex();
  static const int kLedgerIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 ledgerindex() const;
  inline void set_ledgerindex(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:newcoin.GetValidations)
 private:
  inline void set_has_ledgerindex();
  inline void clear_has_ledgerindex();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 ledgerindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static GetValidations* default_instance_;
};
// -------------------------------------------------------------------

class Contact : public ::google::protobuf::Message {
 public:
  Contact();
  virtual ~Contact();
  
  Contact(const Contact& from);
  
  inline Contact& operator=(const Contact& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Contact& default_instance();
  
  void Swap(Contact* other);
  
  // implements Message ----------------------------------------------
  
  Contact* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Contact& from);
  void MergeFrom(const Contact& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string nodeID = 1;
  inline bool has_nodeid() const;
  inline void clear_nodeid();
  static const int kNodeIDFieldNumber = 1;
  inline const ::std::string& nodeid() const;
  inline void set_nodeid(const ::std::string& value);
  inline void set_nodeid(const char* value);
  inline void set_nodeid(const char* value, size_t size);
  inline ::std::string* mutable_nodeid();
  inline ::std::string* release_nodeid();
  
  // required string nodeIP = 2;
  inline bool has_nodeip() const;
  inline void clear_nodeip();
  static const int kNodeIPFieldNumber = 2;
  inline const ::std::string& nodeip() const;
  inline void set_nodeip(const ::std::string& value);
  inline void set_nodeip(const char* value);
  inline void set_nodeip(const char* value, size_t size);
  inline ::std::string* mutable_nodeip();
  inline ::std::string* release_nodeip();
  
  // required int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:newcoin.Contact)
 private:
  inline void set_has_nodeid();
  inline void clear_has_nodeid();
  inline void set_has_nodeip();
  inline void clear_has_nodeip();
  inline void set_has_port();
  inline void clear_has_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nodeid_;
  ::std::string* nodeip_;
  ::google::protobuf::int32 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static Contact* default_instance_;
};
// -------------------------------------------------------------------

class ProposeLedger : public ::google::protobuf::Message {
 public:
  ProposeLedger();
  virtual ~ProposeLedger();
  
  ProposeLedger(const ProposeLedger& from);
  
  inline ProposeLedger& operator=(const ProposeLedger& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProposeLedger& default_instance();
  
  void Swap(ProposeLedger* other);
  
  // implements Message ----------------------------------------------
  
  ProposeLedger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProposeLedger& from);
  void MergeFrom(const ProposeLedger& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 ledgerIndex = 1;
  inline bool has_ledgerindex() const;
  inline void clear_ledgerindex();
  static const int kLedgerIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 ledgerindex() const;
  inline void set_ledgerindex(::google::protobuf::uint32 value);
  
  // required bytes hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  
  // optional uint64 numTransactions = 3;
  inline bool has_numtransactions() const;
  inline void clear_numtransactions();
  static const int kNumTransactionsFieldNumber = 3;
  inline ::google::protobuf::uint64 numtransactions() const;
  inline void set_numtransactions(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:newcoin.ProposeLedger)
 private:
  inline void set_has_ledgerindex();
  inline void clear_has_ledgerindex();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_numtransactions();
  inline void clear_has_numtransactions();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* hash_;
  ::google::protobuf::uint64 numtransactions_;
  ::google::protobuf::uint32 ledgerindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static ProposeLedger* default_instance_;
};
// -------------------------------------------------------------------

class ErrorMsg : public ::google::protobuf::Message {
 public:
  ErrorMsg();
  virtual ~ErrorMsg();
  
  ErrorMsg(const ErrorMsg& from);
  
  inline ErrorMsg& operator=(const ErrorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorMsg& default_instance();
  
  void Swap(ErrorMsg* other);
  
  // implements Message ----------------------------------------------
  
  ErrorMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ErrorMsg& from);
  void MergeFrom(const ErrorMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);
  
  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // @@protoc_insertion_point(class_scope:newcoin.ErrorMsg)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_message();
  inline void clear_has_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* message_;
  ::google::protobuf::int32 errorcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_newcoin_2eproto();
  friend void protobuf_AssignDesc_newcoin_2eproto();
  friend void protobuf_ShutdownFile_newcoin_2eproto();
  
  void InitAsDefaultInstance();
  static ErrorMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// Hello

// required int32 version = 1;
inline bool Hello::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hello::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hello::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hello::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Hello::version() const {
  return version_;
}
inline void Hello::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// required bytes nodeID = 2;
inline bool Hello::has_nodeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Hello::set_has_nodeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Hello::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Hello::clear_nodeid() {
  if (nodeid_ != &::google::protobuf::internal::kEmptyString) {
    nodeid_->clear();
  }
  clear_has_nodeid();
}
inline const ::std::string& Hello::nodeid() const {
  return *nodeid_;
}
inline void Hello::set_nodeid(const ::std::string& value) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(value);
}
inline void Hello::set_nodeid(const char* value) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(value);
}
inline void Hello::set_nodeid(const void* value, size_t size) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hello::mutable_nodeid() {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  return nodeid_;
}
inline ::std::string* Hello::release_nodeid() {
  clear_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodeid_;
    nodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 port = 3;
inline bool Hello::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Hello::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Hello::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Hello::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Hello::port() const {
  return port_;
}
inline void Hello::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// Transaction

// required bytes from = 1;
inline bool Transaction::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Transaction::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Transaction::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Transaction::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& Transaction::from() const {
  return *from_;
}
inline void Transaction::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void Transaction::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void Transaction::set_from(const void* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Transaction::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* Transaction::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes dest = 2;
inline bool Transaction::has_dest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Transaction::set_has_dest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Transaction::clear_has_dest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Transaction::clear_dest() {
  if (dest_ != &::google::protobuf::internal::kEmptyString) {
    dest_->clear();
  }
  clear_has_dest();
}
inline const ::std::string& Transaction::dest() const {
  return *dest_;
}
inline void Transaction::set_dest(const ::std::string& value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
}
inline void Transaction::set_dest(const char* value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
}
inline void Transaction::set_dest(const void* value, size_t size) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Transaction::mutable_dest() {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  return dest_;
}
inline ::std::string* Transaction::release_dest() {
  clear_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dest_;
    dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 amount = 3;
inline bool Transaction::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Transaction::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Transaction::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Transaction::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 Transaction::amount() const {
  return amount_;
}
inline void Transaction::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// required uint32 ledgerIndex = 4;
inline bool Transaction::has_ledgerindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Transaction::set_has_ledgerindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Transaction::clear_has_ledgerindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Transaction::clear_ledgerindex() {
  ledgerindex_ = 0u;
  clear_has_ledgerindex();
}
inline ::google::protobuf::uint32 Transaction::ledgerindex() const {
  return ledgerindex_;
}
inline void Transaction::set_ledgerindex(::google::protobuf::uint32 value) {
  set_has_ledgerindex();
  ledgerindex_ = value;
}

// required int32 seqNum = 5;
inline bool Transaction::has_seqnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Transaction::set_has_seqnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Transaction::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Transaction::clear_seqnum() {
  seqnum_ = 0;
  clear_has_seqnum();
}
inline ::google::protobuf::int32 Transaction::seqnum() const {
  return seqnum_;
}
inline void Transaction::set_seqnum(::google::protobuf::int32 value) {
  set_has_seqnum();
  seqnum_ = value;
}

// required bytes pubKey = 6;
inline bool Transaction::has_pubkey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Transaction::set_has_pubkey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Transaction::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Transaction::clear_pubkey() {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    pubkey_->clear();
  }
  clear_has_pubkey();
}
inline const ::std::string& Transaction::pubkey() const {
  return *pubkey_;
}
inline void Transaction::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void Transaction::set_pubkey(const char* value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void Transaction::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Transaction::mutable_pubkey() {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  return pubkey_;
}
inline ::std::string* Transaction::release_pubkey() {
  clear_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pubkey_;
    pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes sig = 7;
inline bool Transaction::has_sig() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Transaction::set_has_sig() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Transaction::clear_has_sig() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Transaction::clear_sig() {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    sig_->clear();
  }
  clear_has_sig();
}
inline const ::std::string& Transaction::sig() const {
  return *sig_;
}
inline void Transaction::set_sig(const ::std::string& value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void Transaction::set_sig(const char* value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void Transaction::set_sig(const void* value, size_t size) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Transaction::mutable_sig() {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  return sig_;
}
inline ::std::string* Transaction::release_sig() {
  clear_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sig_;
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Validation

// required uint32 ledgerIndex = 1;
inline bool Validation::has_ledgerindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Validation::set_has_ledgerindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Validation::clear_has_ledgerindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Validation::clear_ledgerindex() {
  ledgerindex_ = 0u;
  clear_has_ledgerindex();
}
inline ::google::protobuf::uint32 Validation::ledgerindex() const {
  return ledgerindex_;
}
inline void Validation::set_ledgerindex(::google::protobuf::uint32 value) {
  set_has_ledgerindex();
  ledgerindex_ = value;
}

// required bytes hash = 2;
inline bool Validation::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Validation::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Validation::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Validation::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& Validation::hash() const {
  return *hash_;
}
inline void Validation::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void Validation::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void Validation::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Validation::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* Validation::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes hanko = 3;
inline bool Validation::has_hanko() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Validation::set_has_hanko() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Validation::clear_has_hanko() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Validation::clear_hanko() {
  if (hanko_ != &::google::protobuf::internal::kEmptyString) {
    hanko_->clear();
  }
  clear_has_hanko();
}
inline const ::std::string& Validation::hanko() const {
  return *hanko_;
}
inline void Validation::set_hanko(const ::std::string& value) {
  set_has_hanko();
  if (hanko_ == &::google::protobuf::internal::kEmptyString) {
    hanko_ = new ::std::string;
  }
  hanko_->assign(value);
}
inline void Validation::set_hanko(const char* value) {
  set_has_hanko();
  if (hanko_ == &::google::protobuf::internal::kEmptyString) {
    hanko_ = new ::std::string;
  }
  hanko_->assign(value);
}
inline void Validation::set_hanko(const void* value, size_t size) {
  set_has_hanko();
  if (hanko_ == &::google::protobuf::internal::kEmptyString) {
    hanko_ = new ::std::string;
  }
  hanko_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Validation::mutable_hanko() {
  set_has_hanko();
  if (hanko_ == &::google::protobuf::internal::kEmptyString) {
    hanko_ = new ::std::string;
  }
  return hanko_;
}
inline ::std::string* Validation::release_hanko() {
  clear_has_hanko();
  if (hanko_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hanko_;
    hanko_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 seqNum = 4;
inline bool Validation::has_seqnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Validation::set_has_seqnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Validation::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Validation::clear_seqnum() {
  seqnum_ = 0;
  clear_has_seqnum();
}
inline ::google::protobuf::int32 Validation::seqnum() const {
  return seqnum_;
}
inline void Validation::set_seqnum(::google::protobuf::int32 value) {
  set_has_seqnum();
  seqnum_ = value;
}

// required bytes sig = 5;
inline bool Validation::has_sig() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Validation::set_has_sig() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Validation::clear_has_sig() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Validation::clear_sig() {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    sig_->clear();
  }
  clear_has_sig();
}
inline const ::std::string& Validation::sig() const {
  return *sig_;
}
inline void Validation::set_sig(const ::std::string& value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void Validation::set_sig(const char* value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void Validation::set_sig(const void* value, size_t size) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Validation::mutable_sig() {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  return sig_;
}
inline ::std::string* Validation::release_sig() {
  clear_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sig_;
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Account

// required bytes address = 1;
inline bool Account::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Account::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Account::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Account::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& Account::address() const {
  return *address_;
}
inline void Account::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Account::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Account::set_address(const void* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Account::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* Account::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 amount = 2;
inline bool Account::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Account::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Account::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Account::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 Account::amount() const {
  return amount_;
}
inline void Account::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// required uint32 seqNum = 3;
inline bool Account::has_seqnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Account::set_has_seqnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Account::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Account::clear_seqnum() {
  seqnum_ = 0u;
  clear_has_seqnum();
}
inline ::google::protobuf::uint32 Account::seqnum() const {
  return seqnum_;
}
inline void Account::set_seqnum(::google::protobuf::uint32 value) {
  set_has_seqnum();
  seqnum_ = value;
}

// -------------------------------------------------------------------

// FullLedger

// required uint32 index = 1;
inline bool FullLedger::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FullLedger::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FullLedger::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FullLedger::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 FullLedger::index() const {
  return index_;
}
inline void FullLedger::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required bytes hash = 2;
inline bool FullLedger::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FullLedger::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FullLedger::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FullLedger::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& FullLedger::hash() const {
  return *hash_;
}
inline void FullLedger::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void FullLedger::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void FullLedger::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FullLedger::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* FullLedger::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes parentHash = 3;
inline bool FullLedger::has_parenthash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FullLedger::set_has_parenthash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FullLedger::clear_has_parenthash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FullLedger::clear_parenthash() {
  if (parenthash_ != &::google::protobuf::internal::kEmptyString) {
    parenthash_->clear();
  }
  clear_has_parenthash();
}
inline const ::std::string& FullLedger::parenthash() const {
  return *parenthash_;
}
inline void FullLedger::set_parenthash(const ::std::string& value) {
  set_has_parenthash();
  if (parenthash_ == &::google::protobuf::internal::kEmptyString) {
    parenthash_ = new ::std::string;
  }
  parenthash_->assign(value);
}
inline void FullLedger::set_parenthash(const char* value) {
  set_has_parenthash();
  if (parenthash_ == &::google::protobuf::internal::kEmptyString) {
    parenthash_ = new ::std::string;
  }
  parenthash_->assign(value);
}
inline void FullLedger::set_parenthash(const void* value, size_t size) {
  set_has_parenthash();
  if (parenthash_ == &::google::protobuf::internal::kEmptyString) {
    parenthash_ = new ::std::string;
  }
  parenthash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FullLedger::mutable_parenthash() {
  set_has_parenthash();
  if (parenthash_ == &::google::protobuf::internal::kEmptyString) {
    parenthash_ = new ::std::string;
  }
  return parenthash_;
}
inline ::std::string* FullLedger::release_parenthash() {
  clear_has_parenthash();
  if (parenthash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parenthash_;
    parenthash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 feeHeld = 4;
inline bool FullLedger::has_feeheld() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FullLedger::set_has_feeheld() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FullLedger::clear_has_feeheld() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FullLedger::clear_feeheld() {
  feeheld_ = GOOGLE_ULONGLONG(0);
  clear_has_feeheld();
}
inline ::google::protobuf::uint64 FullLedger::feeheld() const {
  return feeheld_;
}
inline void FullLedger::set_feeheld(::google::protobuf::uint64 value) {
  set_has_feeheld();
  feeheld_ = value;
}

// repeated .newcoin.Account accounts = 5;
inline int FullLedger::accounts_size() const {
  return accounts_.size();
}
inline void FullLedger::clear_accounts() {
  accounts_.Clear();
}
inline const ::newcoin::Account& FullLedger::accounts(int index) const {
  return accounts_.Get(index);
}
inline ::newcoin::Account* FullLedger::mutable_accounts(int index) {
  return accounts_.Mutable(index);
}
inline ::newcoin::Account* FullLedger::add_accounts() {
  return accounts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::newcoin::Account >&
FullLedger::accounts() const {
  return accounts_;
}
inline ::google::protobuf::RepeatedPtrField< ::newcoin::Account >*
FullLedger::mutable_accounts() {
  return &accounts_;
}

// repeated .newcoin.Transaction transactions = 6;
inline int FullLedger::transactions_size() const {
  return transactions_.size();
}
inline void FullLedger::clear_transactions() {
  transactions_.Clear();
}
inline const ::newcoin::Transaction& FullLedger::transactions(int index) const {
  return transactions_.Get(index);
}
inline ::newcoin::Transaction* FullLedger::mutable_transactions(int index) {
  return transactions_.Mutable(index);
}
inline ::newcoin::Transaction* FullLedger::add_transactions() {
  return transactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::newcoin::Transaction >&
FullLedger::transactions() const {
  return transactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::newcoin::Transaction >*
FullLedger::mutable_transactions() {
  return &transactions_;
}

// -------------------------------------------------------------------

// GetFullLedger

// required bytes hash = 1;
inline bool GetFullLedger::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFullLedger::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFullLedger::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFullLedger::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& GetFullLedger::hash() const {
  return *hash_;
}
inline void GetFullLedger::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void GetFullLedger::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void GetFullLedger::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFullLedger::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* GetFullLedger::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetValidations

// required uint32 ledgerIndex = 1;
inline bool GetValidations::has_ledgerindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetValidations::set_has_ledgerindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetValidations::clear_has_ledgerindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetValidations::clear_ledgerindex() {
  ledgerindex_ = 0u;
  clear_has_ledgerindex();
}
inline ::google::protobuf::uint32 GetValidations::ledgerindex() const {
  return ledgerindex_;
}
inline void GetValidations::set_ledgerindex(::google::protobuf::uint32 value) {
  set_has_ledgerindex();
  ledgerindex_ = value;
}

// -------------------------------------------------------------------

// Contact

// required string nodeID = 1;
inline bool Contact::has_nodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Contact::set_has_nodeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Contact::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Contact::clear_nodeid() {
  if (nodeid_ != &::google::protobuf::internal::kEmptyString) {
    nodeid_->clear();
  }
  clear_has_nodeid();
}
inline const ::std::string& Contact::nodeid() const {
  return *nodeid_;
}
inline void Contact::set_nodeid(const ::std::string& value) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(value);
}
inline void Contact::set_nodeid(const char* value) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(value);
}
inline void Contact::set_nodeid(const char* value, size_t size) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Contact::mutable_nodeid() {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  return nodeid_;
}
inline ::std::string* Contact::release_nodeid() {
  clear_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodeid_;
    nodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string nodeIP = 2;
inline bool Contact::has_nodeip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Contact::set_has_nodeip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Contact::clear_has_nodeip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Contact::clear_nodeip() {
  if (nodeip_ != &::google::protobuf::internal::kEmptyString) {
    nodeip_->clear();
  }
  clear_has_nodeip();
}
inline const ::std::string& Contact::nodeip() const {
  return *nodeip_;
}
inline void Contact::set_nodeip(const ::std::string& value) {
  set_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::kEmptyString) {
    nodeip_ = new ::std::string;
  }
  nodeip_->assign(value);
}
inline void Contact::set_nodeip(const char* value) {
  set_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::kEmptyString) {
    nodeip_ = new ::std::string;
  }
  nodeip_->assign(value);
}
inline void Contact::set_nodeip(const char* value, size_t size) {
  set_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::kEmptyString) {
    nodeip_ = new ::std::string;
  }
  nodeip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Contact::mutable_nodeip() {
  set_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::kEmptyString) {
    nodeip_ = new ::std::string;
  }
  return nodeip_;
}
inline ::std::string* Contact::release_nodeip() {
  clear_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodeip_;
    nodeip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 port = 3;
inline bool Contact::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Contact::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Contact::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Contact::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Contact::port() const {
  return port_;
}
inline void Contact::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// ProposeLedger

// required uint32 ledgerIndex = 1;
inline bool ProposeLedger::has_ledgerindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProposeLedger::set_has_ledgerindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProposeLedger::clear_has_ledgerindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProposeLedger::clear_ledgerindex() {
  ledgerindex_ = 0u;
  clear_has_ledgerindex();
}
inline ::google::protobuf::uint32 ProposeLedger::ledgerindex() const {
  return ledgerindex_;
}
inline void ProposeLedger::set_ledgerindex(::google::protobuf::uint32 value) {
  set_has_ledgerindex();
  ledgerindex_ = value;
}

// required bytes hash = 2;
inline bool ProposeLedger::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProposeLedger::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProposeLedger::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProposeLedger::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& ProposeLedger::hash() const {
  return *hash_;
}
inline void ProposeLedger::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void ProposeLedger::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void ProposeLedger::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProposeLedger::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* ProposeLedger::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint64 numTransactions = 3;
inline bool ProposeLedger::has_numtransactions() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProposeLedger::set_has_numtransactions() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProposeLedger::clear_has_numtransactions() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProposeLedger::clear_numtransactions() {
  numtransactions_ = GOOGLE_ULONGLONG(0);
  clear_has_numtransactions();
}
inline ::google::protobuf::uint64 ProposeLedger::numtransactions() const {
  return numtransactions_;
}
inline void ProposeLedger::set_numtransactions(::google::protobuf::uint64 value) {
  set_has_numtransactions();
  numtransactions_ = value;
}

// -------------------------------------------------------------------

// ErrorMsg

// optional int32 errorCode = 1;
inline bool ErrorMsg::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorMsg::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorMsg::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorMsg::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 ErrorMsg::errorcode() const {
  return errorcode_;
}
inline void ErrorMsg::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional string message = 2;
inline bool ErrorMsg::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ErrorMsg::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ErrorMsg::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ErrorMsg::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ErrorMsg::message() const {
  return *message_;
}
inline void ErrorMsg::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ErrorMsg::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ErrorMsg::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ErrorMsg::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ErrorMsg::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace newcoin

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< newcoin::Type>() {
  return newcoin::Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_newcoin_2eproto__INCLUDED
